<H2>Overview</H2>

<P>The Kubernetes API is a resource-based (RESTful) programmatic interface
provided through HTTP.
The REST API is the fundamental fabric of Kubernetes, exposed by the API server.
With the API, you can:
</P>

<ul>
  <li>create, retrieve, update and delete primary resources via the standard HTTP
    verbs (<code>POST</code>, <code>PUT</code>, <code>PATCH</code>,
    <code>DELETE</code>, <code>GET</code>).
  </li>
  <li>operate the additional subresources for objects that support them.
  </li>
  <li>instruct the API server to return responses in specific format for
    convenience or efficiency. 
  </li>
  <li>watch the changes on certain resources to get notifications.
  </li>
  <li>retrieve a consistent list of resources to allow other components to
    effectively cache and sync the resource states.
  </li>
</ul>

<H2 id="objects">Objects</H2>

<P>Kubernetes objects are persistent entities that represent a concrete
instance of a concept in the cluster. Collectively, these objects form the
state of your cluster. 
Each object is a <I>record of intent</I>. Once an object is created, the system
constantly works to ensure that object exists.
</P>

<P>Most Kubernetes objects have following fields that govern the object's
configuration:</P>

<ul>
  <li><code>apiVersion</code>: the <a href="">API group and version</a> used
    for creating or updating the object.
  </li>
  <li><code>kind</code>: the <a href="">kind</a> of the object you want to
    operate on.
  </li>
  <li><code>metadata</code>: the data that helps uniquely identify an object,
    for example, a <code>name</code> string, a <code>UID</code> and the
    <code>namespace</code> the object resides in.
  </li>
  <li><code>spec</code>: the *desired state*, i.e. properties you want the
    object to have.
  </li>
  <li><code>status</code>: the *current state* of the object, as supplied and
    updated by the system.
  </li>
</ul>

<H2>API Groups and Versioning</H2>

<P>Kubernetes supports multiple API versions, each at a different API path, such
as <code>/api/v1</code> or <code>/apis/rbac.authorization.k8s.io/v1alpha1</code>.
</P>

<H3>API Group</H3>

<P>API groups make it easier to extend the Kubernetes API. The API group is
specified in a REST path and in the <code>apiVersion</code> field of a
serialized object.
</P>

<P>There are several API groups in Kubernetes:

<ul>
  <li>The <code>core</code> (also called <code>legacy</code>) group is found
    at REST path <code>/api/v1</code>. The <code>core</code> group is not
    specified as part of the <code>apiVersion</code> field, for example,
    <code>apiVersion: v1</code>.
  </li>
  <li>The named groups are at REST path <code>/apis/$GROUP_NAME/$VERSION</code>
    and use <code>apiVersion: $GROUP_NAME/$VERSION</code>
    (for example, <code>apiVersion: batch/v1</code>).
  </li>
</ul>

<B>TODO</B> List of API Groups

<H4>Enabling/Disabling API Groups</H4>

<p>Certain Resources and API groups are enabled by default. You can enable or
disable them by setting <code>--runtime-config</code> on the API server.
The <code>--runtime-config</code> flag accepts comma separated
<code>&lt;key&gt;[=&lt;value&gt;]</code> pairs describing the runtime
configuration of the API server. If the <code>=value&gt;</code> part is
omitted, it is treated as if <code>=true</code> is specified.
For example:
</p>

<ul>
  <li>to disable <code>batch/v1</code>, set <code>--runtime-config=batch/v1=false</code>;
  </li>
  <li>to enable <code>batch/v2alpha1</code>, set <code>--runtime-config=batch/v2alpha1</code>
  </li>
</ul>

<p>
Note: When you enable or disable groups or resources, you need to restart the
API server and controller manager to pick up the <code>--runtime-config</code>
changes.
</p>

<H3>API Resources</H3>

<H4>Resource Scope</H4>

<P>All resource types are either scoped by the cluster or to a namespace.
A namespace-scoped resource type will be deleted when its namespace is deleted
and access to that resource type is controlled by authorization checks on the
namespace scope.</P>


<H4>Resource Type versus Resource</H4>

<P>A <B>resource type</B> is the name used in the API path, e.g. <code>pods</code>,
<code>namespaces</code>. All resource types have a concrete schema which is
called a <B>kind</B>.</P>

<P>A list of instances of a resource type is known as a <B>collection</B>.
A single instance of the resource type is called a <B>resource</B>.
</P>

<H4>Resources versus Objects</H4>

<P>Most API resources are <a href="#objects">objects</a>.
A small number of types of resources are "virtual" concepts. They represent
operations rather than objects, such as a permission check.
All objects have a unique name to allow idempotent creation, but virtual
resources may not have unique names if they are not retrievable or do not
rely on idempotency.
</P>

<P>API resources are distinguished by their API group, resource kind, namespace
(for namespaced resources), and name. The API server may serve the same
underlying data through multiple API versions and handle the conversion between
API versions transparently. All these different versions are actually representations
of the same resource.
</P>

<P>For example, suppose there are two versions <code>v1</code> and <code>v1beta1</code>
for the same resource. An object created by the <code>v1beta1</code> version
can then be read, updated, and deleted by either the <code>v1beta1</code> or
the <code>v1</code> versions.
</P>

<H4>Sub-Resources</H4>

<P>Some resource types will have one or more <B>sub-resources</B>,
represented as sub paths below the resource.
</P>

<H4>Resource Version</H4>

<P>Every Kubernetes object has a resourceVersion field representing the
version of that resource as stored in the underlying database.
</P>

<P>For a collection of resources (either namespace or cluster scoped) returned
from the API server, the response contains a <code>resourceVersion</code>
value that can be used to initiate a <code>watch</code> against the server.</P>

<H3>API Versions</H3>

<P>Versioning is done at the API group level rather than at the resource or field
level to ensure that the API presents a clear, consistent view of system resources
and behavior, and to enable controlling access to end-of-life and/or
experimental APIs.
</P>

<P>The JSON and Protobuf serialization schemas follow the same guidelines for
schema changes. The following descriptions cover both formats.
</P>

<P>The API versioning and software versioning are indirectly related. The
<a href="https://git.k8s.io/community/contributors/design-proposals/release/versioning.md">
  API and release versioning proposal</a> describes the relationship between
API versioning and software versioning.
</P>

<P>Different API versions indicate different levels of stability and support. You
can find more information about the criteria for each level in the
<a href="">API Changes</a> documentation.
</P>

<P>Here's a summary of each level:</P>

<ul>
  <li><B>Alpha</B>:
    <ul>
      <li>The version names contain alpha (for example, v1alpha1).</li>
      <li>The software may contain bugs. Enabling a feature may expose bugs. A feature may be disabled by default.</li>
      <li>The support for a feature may be dropped at any time without notice.</li>
      <li>The API may change in incompatible ways in a later software release without notice.</li>
      <li>The software is recommended for use only in short-lived testing clusters, due to increased risk of bugs and
        lack of long-term support.</li>
    </ul>
  </li>
  <li><B>Beta</B>:
    <ul>
      <li>The version names contain beta (for example, <tt>v2beta3</tt>).
      </li>
      <li>The software is well tested. Enabling a feature is considered safe.
        Features are enabled by default.
      </li>
      <li>The support for a feature will not be dropped, though the details may change.
      </li>
      <li>The schema and/or semantics of objects may change in incompatible
        ways in a subsequent beta or stable release. When this happens,
        migration instructions are provided. Schema changes may require
        deleting, editing, and re-creating API objects. The editing process
        may not be straightforward. The migration may require downtime for
        applications that rely on the feature.
      </li>
      <li>The feature is not recommended for production uses. Subsequent
        releases may introduce incompatible changes. If you have multiple
        clusters which can be upgraded independently, you may be able to relax
        this restriction.
      </li>
    </ul>
  </li>
  <li><B>Stable/GA</B>:
    <ul>
      <li>The version name is vX where X is an integer.
      </li>
      <li>The stable versions of features appear in released software for many
        subsequent versions.
      </li>
    </ul>
  </li>
</ul>

<H2>The OpenAPI Specification</H2>

The official API specification is generated in the
<a href="https://www.openapis.org/">OpenAPI V2</a>
format from the Go source code.



