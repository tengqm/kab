<H2>Invocation</H2>

<P>You can use the <kbd>kubectl</kbd> command line interface to invoke the API
and you can use other tools as well. There are
<a href="https://kubernetes.io/docs/reference/using-api/client-libraries/">client libraries</a>
to use if you are writing applications to invoke the API.

<H3>HTTP Verbs</H3>

<P>Almost all object resource types support the standard HTTP verbs - 
<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>PATCH</code>,
and <code>DELETE</code>. Kubernetes uses the term <B>list</B> to describe
returning a collection of resources to distinguish from retrieving a single
resource which is usually called a <B>read</B>.

The verbs supported for subresources differ depending on the object. It is
NOTE possible to access sub-resources across multiple resources.
Generally a new, "virtual" resource type would be used if that becomes necessary.

<H3>HTTP Path</H3>

<P>The following paths are used to retrieve collections and resources:</P>

<P><B>Cluster-scoped resources</B>:</P>

<ul>
  <li><code>GET /apis/GROUP/VERSION/RESOURCETYPE</code> -
    return the collection of resources of the resource type
  </li>
  <li><code>GET /apis/GROUP/VERSION/RESOURCETYPE/NAME</code> -
    return the resource with NAME under the resource type
  </li>
  <li><code>GET /apis/GROUP/VERSION/RESOURCETYPE/NAME/SUBRESOURCE</code> -
    return the subresource SUBRESOURCE under the resource NAME
  </li>
</ul>

<P><B>Namespace-scoped resources</B>:</P>

<ul>
  <li><code>GET /apis/GROUP/VERSION/RESOURCETYPE</code> -
    return the collection of all instances of the resource type across all
    namespaces.
  </li>
  <li><code>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE</code> -
    return collection of all instances of the resource type in NAMESPACE
  </li>
  <li><code>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME</code> -
    return the instance of the resource type with NAME in NAMESPACE
  </li>
  <li><code>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME/SUBRESOURCE</code> -
    return the subresource SUBRESOURCE under resource NAME.
  </li>
</ul>

<P>Since a <code>namespace</code> is a <u>cluster-scoped</u> resource type,
you can retrieve the list of all namespaces with
<code>GET /api/v1/namespaces</code> and details about a particular namespace
with <code>GET /api/v1/namespaces/NAME</code>.</P>

<H3>Request Format</H3>

Requests sent to the API server can be encoded in one of the following formats:

<ul>
  <li><code>application/json</code>
    Request payload is encoded in JSON format.
  </li>
  <li><code>application/yaml</code>
    Request payload is encoded in YAML.
  </li>
  <li><code>application/vnd.kubernetes.protobuf</code>
    Request payload is encoded in
    <a href="https://developers.google.com/protocol-buffers">protocol buffers</a> format.
  </li>
</ul>

<H3>Specifying the Response Encoding</H3>

You can customize the response format by specifying the following HTTP request
headers.

<ul>
  <li><code>Accept-Encoding</code>
    The accepted value is "<tt>gzip</tt>". It is acceptable to omit this header.
  </li>
  <li><code>Accept</code>
    The valid values can be one of:
    <ul>
      <li><code>application/com.github.proto-openapi.spec.v2@v1.0+protobuf</code>
        This is mainly used for intra-cluster communnications.
      </li>
      <li><code>application/json</code>
        This is the default value indicating that the server response is expecected
        to be JSON data.
      </li>
      <li><code>application/json;stream=watch</code>
        The server response is expecected to be JSON data stream for watch operations.
      </li>
      <li><code>application/yaml</code>
        The server response are encoded in YAML format.
      </li>
      <li><code>application/vnd.kubernetes.protobuf</code>
        The server response are encoded in 
        <a href="https://developers.google.com/protocol-buffers">protocol buffers</a> format.
      </li>
      <li><code>application/vnd.kubernetes.protobuf;stream=watch</code>
        The same as <code>application/vnd.kubernetes.protobuf</code> except that
        the response will be an stream.
      </li>
      <li><code>*</code>
        The server response is encoded in "<tt>application/json</tt>".
      </li>
    </ul>
  </li>
</ul>

<H3>Watch Object Changes</H3>

<P>To enable clients to build a model of the current state of a cluster, all
Kubernetes object resource types are required to support consistent lists and
an incremental change notification feed called a <B>watch</B>.</P>

When a <code>list/watch</code> operation is initiated with a
<code>resourceVersion</code> specified, the server will return all changes
(creates, deletes, and updates) that occur after the supplied
<code>resourceVersion</code>.
This allows a client to fetch the current state and then watch for changes
without missing any updates. If the client watch is disconnected they can
restart a new <code>watch</code> from the last returned
<code>resourceVersion</code>, or perform a new <code>collection</code> request
and begin again.

<p>For example, to list all of the Pods in a given namespace.</p>

<pre><code class=language-console data-lang=console>
GET /api/v1/namespaces/test/pods
---
200 OK
Content-Type: application/json

{
  "kind": "PodList",
  "apiVersion": "v1",
  "metadata": {"resourceVersion":"10245"},
  "items": [...]
}
</code></pre>

<p>To list all Pods starting from resource version 10245, receive
notifications of any creates, deletes, or updates as individual JSON objects.
</P>

<pre><code>
GET /api/v1/namespaces/test/pods?watch=1&amp;resourceVersion=10245
---
200 OK
Transfer-Encoding: chunked
Content-Type: application/json

{
  "type": "ADDED",
  "object": {"kind": "Pod", "apiVersion": "v1", "metadata": {"resourceVersion": "10596", ...}, ...}
}
{
  "type": "MODIFIED",
  "object": {"kind": "Pod", "apiVersion": "v1", "metadata": {"resourceVersion": "11020", ...}, ...}
}
...
</code></pre>

<p>A given Kubernetes server will only preserve a historical list of changes
for a limited time. Clusters using etcd3 preserve changes in the last 5
minutes by default. When the requested watch operations fail because the
historical version of that resource is not available, clients must handle the
case by recognizing the status code <code>410 Gone</code>, clearing their
local cache, performing a list operation, and starting the watch from the
<code>resourceVersion</code> returned by that new list operation.
</P>

<P>Most client libraries offer some form of standard tool for this logic.
(In Go this is called a <code>Reflector</code> and is located in the
<code>k8s.io/client-go/cache</code> package.)</p>

<H4 id="watch-bookmarks">Watch bookmarks</H4>

<p>To mitigate the impact of short history window, we introduced a concept
of <code>bookmark</code> watch event. It is a special kind of event to mark
that all changes up to a given <code>resourceVersion</code> the client is
requesting have already been sent. Object returned in that event is of the
type requested by the request, but only <code>resourceVersion</code> field
is set, e.g.:</p>

<pre><code class=language-console data-lang=console>
GET /api/v1/namespaces/test/pods?watch=1&amp;resourceVersion=10245&amp;allowWatchBookmarks=true
---
200 OK
Transfer-Encoding: chunked
Content-Type: application/json

{
  "type": "ADDED",
  "object": {"kind": "Pod", "apiVersion": "v1", "metadata": {"resourceVersion": "10596", ...}, ...}
}
...
{
  "type": "BOOKMARK",
  "object": {"kind": "Pod", "apiVersion": "v1", "metadata": {"resourceVersion": "12746"} }
}
</code></pre>

<p><code>Bookmark</code> events can be requested by
<code>allowWatchBookmarks=true</code> option in <code>watch</code> requests,
but clients shouldn't assume bookmarks are returned at any specific interval,
nor may they assume the server will send any <code>bookmark</code> event.</p>
