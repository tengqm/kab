# Only in 1.30orig/defs: io.k8s.api.admissionregistration.v1.AuditAnnotation.json
# Only in 1.30orig/defs: io.k8s.api.admissionregistration.v1.ExpressionWarning.json
# Only in 1.30orig/defs: io.k8s.api.admissionregistration.v1.MatchResources.json
# Only in 1.30orig/defs: io.k8s.api.admissionregistration.v1.Validation.json
# Only in 1.30orig/defs: io.k8s.api.admissionregistration.v1.Variable.json
# Only in 1.30orig/defs: io.k8s.api.admissionregistration.v1.NamedRuleWithOperations.json
# Only in 1.30orig/defs: io.k8s.api.admissionregistration.v1.ParamKind.json
# Only in 1.30orig/defs: io.k8s.api.admissionregistration.v1.ParamRef.json
# Only in 1.30orig/defs: io.k8s.api.admissionregistration.v1.TypeChecking.json
# Only in 1.30orig/defs: io.k8s.api.admissionregistration.v1.ValidatingAdmissionPolicy.json
# Only in 1.30orig/defs: io.k8s.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding.json
# Only in 1.30orig/defs: io.k8s.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingList.json
# Only in 1.30orig/defs: io.k8s.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec.json
# Only in 1.30orig/defs: io.k8s.api.admissionregistration.v1.ValidatingAdmissionPolicyList.json
# Only in 1.30orig/defs: io.k8s.api.admissionregistration.v1.ValidatingAdmissionPolicySpec.json
# Only in 1.30orig/defs: io.k8s.api.admissionregistration.v1.ValidatingAdmissionPolicyStatus.json
# Only in 1.30orig/ops: createAdmissionregistrationV1ValidatingAdmissionPolicy.json
# Only in 1.30orig/ops: createAdmissionregistrationV1ValidatingAdmissionPolicyBinding.json
# Only in 1.30orig/ops: deleteAdmissionregistrationV1CollectionValidatingAdmissionPolicy.json
# Only in 1.30orig/ops: deleteAdmissionregistrationV1CollectionValidatingAdmissionPolicyBinding.json
# Only in 1.30orig/ops: deleteAdmissionregistrationV1ValidatingAdmissionPolicy.json
# Only in 1.30orig/ops: deleteAdmissionregistrationV1ValidatingAdmissionPolicyBinding.json
# Only in 1.30orig/ops: listAdmissionregistrationV1ValidatingAdmissionPolicy.json
# Only in 1.30orig/ops: listAdmissionregistrationV1ValidatingAdmissionPolicyBinding.json
# Only in 1.30orig/ops: patchAdmissionregistrationV1ValidatingAdmissionPolicy.json
# Only in 1.30orig/ops: patchAdmissionregistrationV1ValidatingAdmissionPolicyBinding.json
# Only in 1.30orig/ops: patchAdmissionregistrationV1ValidatingAdmissionPolicyStatus.json
# Only in 1.30orig/ops: readAdmissionregistrationV1ValidatingAdmissionPolicy.json
# Only in 1.30orig/ops: readAdmissionregistrationV1ValidatingAdmissionPolicyBinding.json
# Only in 1.30orig/ops: readAdmissionregistrationV1ValidatingAdmissionPolicyStatus.json
# Only in 1.30orig/ops: replaceAdmissionregistrationV1ValidatingAdmissionPolicy.json
# Only in 1.30orig/ops: replaceAdmissionregistrationV1ValidatingAdmissionPolicyBinding.json
# Only in 1.30orig/ops: replaceAdmissionregistrationV1ValidatingAdmissionPolicyStatus.json
# Only in 1.30orig/ops: watchAdmissionregistrationV1ValidatingAdmissionPolicy.json
# Only in 1.30orig/ops: watchAdmissionregistrationV1ValidatingAdmissionPolicyBinding.json
# Only in 1.30orig/ops: watchAdmissionregistrationV1ValidatingAdmissionPolicyBindingList.json
# Only in 1.30orig/ops: watchAdmissionregistrationV1ValidatingAdmissionPolicyList.json

# Only in 1.30orig/defs: io.k8s.api.resource.v1alpha2.ResourceClassParameters.json
# Only in 1.30orig/defs: io.k8s.api.resource.v1alpha2.ResourceClassParametersList.json
# Only in 1.30orig/defs: io.k8s.api.resource.v1alpha2.ResourceFilter.json
# Only in 1.30orig/defs: io.k8s.api.resource.v1alpha2.NamedResourcesFilter.json
# Only in 1.30orig/defs: io.k8s.api.resource.v1alpha2.ResourceClaimParameters.json
# Only in 1.30orig/defs: io.k8s.api.resource.v1alpha2.ResourceClaimParametersList.json
# Only in 1.30orig/defs: io.k8s.api.resource.v1alpha2.ResourceRequest.json
# Only in 1.30orig/defs: io.k8s.api.resource.v1alpha2.DriverRequests.json
# Only in 1.30orig/defs: io.k8s.api.resource.v1alpha2.ResourceSlice.json
# Only in 1.30orig/defs: io.k8s.api.resource.v1alpha2.ResourceSliceList.json
# Only in 1.30orig/defs: io.k8s.api.resource.v1alpha2.StructuredResourceHandle.json
# Only in 1.30orig/defs: io.k8s.api.resource.v1alpha2.VendorParameters.json
# Only in 1.30orig/defs: io.k8s.api.resource.v1alpha2.DriverAllocationResult.json
# Only in 1.30orig/defs: io.k8s.api.resource.v1alpha2.NamedResourcesAllocationResult.json
# Only in 1.30orig/defs: io.k8s.api.resource.v1alpha2.NamedResourcesAttribute.json
# Only in 1.30orig/defs: io.k8s.api.resource.v1alpha2.NamedResourcesInstance.json
# Only in 1.30orig/defs: io.k8s.api.resource.v1alpha2.NamedResourcesIntSlice.json
# Only in 1.30orig/defs: io.k8s.api.resource.v1alpha2.NamedResourcesRequest.json
# Only in 1.30orig/defs: io.k8s.api.resource.v1alpha2.NamedResourcesResources.json
# Only in 1.30orig/defs: io.k8s.api.resource.v1alpha2.NamedResourcesStringSlice.json

# Only in 1.30orig/ops: createResourceV1alpha2NamespacedResourceClaimParameters.json
# Only in 1.30orig/ops: createResourceV1alpha2NamespacedResourceClassParameters.json
# Only in 1.30orig/ops: createResourceV1alpha2ResourceSlice.json
# Only in 1.30orig/ops: deleteResourceV1alpha2CollectionNamespacedResourceClaimParameters.json
# Only in 1.30orig/ops: deleteResourceV1alpha2CollectionNamespacedResourceClassParameters.json
# Only in 1.30orig/ops: deleteResourceV1alpha2CollectionResourceSlice.json
# Only in 1.30orig/ops: deleteResourceV1alpha2NamespacedResourceClaimParameters.json
# Only in 1.30orig/ops: deleteResourceV1alpha2NamespacedResourceClassParameters.json
# Only in 1.30orig/ops: deleteResourceV1alpha2ResourceSlice.json
# Only in 1.30orig/ops: listResourceV1alpha2NamespacedResourceClaimParameters.json
# Only in 1.30orig/ops: listResourceV1alpha2NamespacedResourceClassParameters.json
# Only in 1.30orig/ops: listResourceV1alpha2ResourceClaimParametersForAllNamespaces.json
# Only in 1.30orig/ops: listResourceV1alpha2ResourceClassParametersForAllNamespaces.json
# Only in 1.30orig/ops: listResourceV1alpha2ResourceSlice.json
# Only in 1.30orig/ops: patchResourceV1alpha2NamespacedResourceClaimParameters.json
# Only in 1.30orig/ops: patchResourceV1alpha2NamespacedResourceClassParameters.json
# Only in 1.30orig/ops: patchResourceV1alpha2ResourceSlice.json
# Only in 1.30orig/ops: readResourceV1alpha2NamespacedResourceClaimParameters.json
# Only in 1.30orig/ops: readResourceV1alpha2NamespacedResourceClassParameters.json
# Only in 1.30orig/ops: readResourceV1alpha2ResourceSlice.json
# Only in 1.30orig/ops: replaceResourceV1alpha2NamespacedResourceClaimParameters.json
# Only in 1.30orig/ops: replaceResourceV1alpha2NamespacedResourceClassParameters.json
# Only in 1.30orig/ops: replaceResourceV1alpha2ResourceSlice.json
# Only in 1.30orig/ops: watchResourceV1alpha2NamespacedResourceClaimParameters.json
# Only in 1.30orig/ops: watchResourceV1alpha2NamespacedResourceClaimParametersList.json
# Only in 1.30orig/ops: watchResourceV1alpha2NamespacedResourceClassParameters.json
# Only in 1.30orig/ops: watchResourceV1alpha2NamespacedResourceClassParametersList.json
# Only in 1.30orig/ops: watchResourceV1alpha2ResourceClaimParametersListForAllNamespaces.json
# Only in 1.30orig/ops: watchResourceV1alpha2ResourceClassParametersListForAllNamespaces.json
# Only in 1.30orig/ops: watchResourceV1alpha2ResourceSlice.json
# Only in 1.30orig/ops: watchResourceV1alpha2ResourceSliceList.json

# Only in 1.30orig/defs: io.k8s.api.storagemigration.v1alpha1.GroupVersionResource.json
# Only in 1.30orig/defs: io.k8s.api.storagemigration.v1alpha1.MigrationCondition.json
# Only in 1.30orig/defs: io.k8s.api.storagemigration.v1alpha1.StorageVersionMigration.json
# Only in 1.30orig/defs: io.k8s.api.storagemigration.v1alpha1.StorageVersionMigrationList.json
# Only in 1.30orig/defs: io.k8s.api.storagemigration.v1alpha1.StorageVersionMigrationSpec.json
# Only in 1.30orig/defs: io.k8s.api.storagemigration.v1alpha1.StorageVersionMigrationStatus.json
# Only in 1.30orig/ops: createStoragemigrationV1alpha1StorageVersionMigration.json
# Only in 1.30orig/ops: deleteStoragemigrationV1alpha1CollectionStorageVersionMigration.json
# Only in 1.30orig/ops: deleteStoragemigrationV1alpha1StorageVersionMigration.json
# Only in 1.30orig/ops: getStoragemigrationAPIGroup.json
# Only in 1.30orig/ops: getStoragemigrationV1alpha1APIResources.json
# Only in 1.30orig/ops: listStoragemigrationV1alpha1StorageVersionMigration.json
# Only in 1.30orig/ops: patchStoragemigrationV1alpha1StorageVersionMigration.json
# Only in 1.30orig/ops: patchStoragemigrationV1alpha1StorageVersionMigrationStatus.json
# Only in 1.30orig/ops: readStoragemigrationV1alpha1StorageVersionMigration.json
# Only in 1.30orig/ops: readStoragemigrationV1alpha1StorageVersionMigrationStatus.json
# Only in 1.30orig/ops: replaceStoragemigrationV1alpha1StorageVersionMigration.json
# Only in 1.30orig/ops: replaceStoragemigrationV1alpha1StorageVersionMigrationStatus.json
# Only in 1.30orig/ops: watchStoragemigrationV1alpha1StorageVersionMigration.json
# Only in 1.30orig/ops: watchStoragemigrationV1alpha1StorageVersionMigrationList.json


# diff -r 1.29orig/defs/io.k8s.api.admissionregistration.v1.MutatingWebhook.json 1.30orig/defs/io.k8s.api.admissionregistration.v1.MutatingWebhook.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 20c21
# <       "description": "MatchConditions is a list of conditions that must be met for a request to be sent to this webhook. Match conditions filter requests that have already been matched by the rules, namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests. There are a maximum of 64 match conditions allowed.\n\nThe exact matching logic is (in order):\n  1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.\n  2. If ALL matchConditions evaluate to TRUE, the webhook is called.\n  3. If any matchCondition evaluates to an error (but none are FALSE):\n     - If failurePolicy=Fail, reject the request\n     - If failurePolicy=Ignore, the error is ignored and the webhook is skipped\n\nThis is a beta feature and managed by the AdmissionWebhookMatchConditions feature gate.",
# ---
# >       "description": "MatchConditions is a list of conditions that must be met for a request to be sent to this webhook. Match conditions filter requests that have already been matched by the rules, namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests. There are a maximum of 64 match conditions allowed.\n\nThe exact matching logic is (in order):\n  1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.\n  2. If ALL matchConditions evaluate to TRUE, the webhook is called.\n  3. If any matchCondition evaluates to an error (but none are FALSE):\n     - If failurePolicy=Fail, reject the request\n     - If failurePolicy=Ignore, the error is ignored and the webhook is skipped",
# 57c58,59
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.admissionregistration.v1.MutatingWebhookConfiguration.json 1.30orig/defs/io.k8s.api.admissionregistration.v1.MutatingWebhookConfiguration.json
# 27a28,31
# >       "x-kubernetes-list-map-keys": [
# >         "name"
# >       ],
# >       "x-kubernetes-list-type": "map",
# diff -r 1.29orig/defs/io.k8s.api.admissionregistration.v1.ValidatingWebhook.json 1.30orig/defs/io.k8s.api.admissionregistration.v1.ValidatingWebhook.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 20c21
# <       "description": "MatchConditions is a list of conditions that must be met for a request to be sent to this webhook. Match conditions filter requests that have already been matched by the rules, namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests. There are a maximum of 64 match conditions allowed.\n\nThe exact matching logic is (in order):\n  1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.\n  2. If ALL matchConditions evaluate to TRUE, the webhook is called.\n  3. If any matchCondition evaluates to an error (but none are FALSE):\n     - If failurePolicy=Fail, reject the request\n     - If failurePolicy=Ignore, the error is ignored and the webhook is skipped\n\nThis is a beta feature and managed by the AdmissionWebhookMatchConditions feature gate.",
# ---
# >       "description": "MatchConditions is a list of conditions that must be met for a request to be sent to this webhook. Match conditions filter requests that have already been matched by the rules, namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests. There are a maximum of 64 match conditions allowed.\n\nThe exact matching logic is (in order):\n  1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.\n  2. If ALL matchConditions evaluate to TRUE, the webhook is called.\n  3. If any matchCondition evaluates to an error (but none are FALSE):\n     - If failurePolicy=Fail, reject the request\n     - If failurePolicy=Ignore, the error is ignored and the webhook is skipped",
# 53c54,55
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.admissionregistration.v1.ValidatingWebhookConfiguration.json 1.30orig/defs/io.k8s.api.admissionregistration.v1.ValidatingWebhookConfiguration.json
# 27a28,31
# >       "x-kubernetes-list-map-keys": [
# >         "name"
# >       ],
# >       "x-kubernetes-list-type": "map",
# diff -r 1.29orig/defs/io.k8s.api.apiserverinternal.v1alpha1.StorageVersionCondition.json 1.30orig/defs/io.k8s.api.apiserverinternal.v1alpha1.StorageVersionCondition.json
# 33c33,34
# <     "reason"
# ---
# >     "reason",
# >     "message"
# diff -r 1.29orig/defs/io.k8s.api.apps.v1.DaemonSetStatus.json 1.30orig/defs/io.k8s.api.apps.v1.DaemonSetStatus.json
# 14a15,18
# >       "x-kubernetes-list-map-keys": [
# >         "type"
# >       ],
# >       "x-kubernetes-list-type": "map",
# diff -r 1.29orig/defs/io.k8s.api.apps.v1.DeploymentStatus.json 1.30orig/defs/io.k8s.api.apps.v1.DeploymentStatus.json
# 19a20,23
# >       "x-kubernetes-list-map-keys": [
# >         "type"
# >       ],
# >       "x-kubernetes-list-type": "map",
# diff -r 1.29orig/defs/io.k8s.api.apps.v1.ReplicaSetStatus.json 1.30orig/defs/io.k8s.api.apps.v1.ReplicaSetStatus.json
# 14a15,18
# >       "x-kubernetes-list-map-keys": [
# >         "type"
# >       ],
# >       "x-kubernetes-list-type": "map",
# diff -r 1.29orig/defs/io.k8s.api.apps.v1.StatefulSetSpec.json 1.30orig/defs/io.k8s.api.apps.v1.StatefulSetSpec.json
# 52c52,53
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.apps.v1.StatefulSetStatus.json 1.30orig/defs/io.k8s.api.apps.v1.StatefulSetStatus.json
# 19a20,23
# >       "x-kubernetes-list-map-keys": [
# >         "type"
# >       ],
# >       "x-kubernetes-list-type": "map",
# diff -r 1.29orig/defs/io.k8s.api.authentication.v1.TokenRequestSpec.json 1.30orig/defs/io.k8s.api.authentication.v1.TokenRequestSpec.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.authentication.v1.TokenReviewSpec.json 1.30orig/defs/io.k8s.api.authentication.v1.TokenReviewSpec.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.authentication.v1.TokenReviewStatus.json 1.30orig/defs/io.k8s.api.authentication.v1.TokenReviewStatus.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.authentication.v1.UserInfo.json 1.30orig/defs/io.k8s.api.authentication.v1.UserInfo.json
# 19c19,20
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.authorization.v1.NonResourceRule.json 1.30orig/defs/io.k8s.api.authorization.v1.NonResourceRule.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 16c17,18
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.authorization.v1.ResourceRule.json 1.30orig/defs/io.k8s.api.authorization.v1.ResourceRule.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 16c17,18
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 23c25,26
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 30c33,34
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.authorization.v1.SubjectAccessReviewSpec.json 1.30orig/defs/io.k8s.api.authorization.v1.SubjectAccessReviewSpec.json
# 19c19,20
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.authorization.v1.SubjectRulesReviewStatus.json 1.30orig/defs/io.k8s.api.authorization.v1.SubjectRulesReviewStatus.json
# 17c17,18
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 24c25,26
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"

# Only in 1.30orig/defs: io.k8s.api.batch.v1.SuccessPolicy.json
# Only in 1.30orig/defs: io.k8s.api.batch.v1.SuccessPolicyRule.json
# diff -r 1.29orig/defs/io.k8s.api.batch.v1.JobSpec.json 1.30orig/defs/io.k8s.api.batch.v1.JobSpec.json
# 27a28,31
# >     "managedBy": {
# >       "description": "ManagedBy field indicates the controller that manages a Job. The k8s Job controller reconciles jobs which don't have this field at all or the field value is the reserved string `kubernetes.io/job-controller`, but skips reconciling Jobs with a custom value for this field. The value must be a valid domain-prefixed path (e.g. acme.io/foo) - all characters before the first \"/\" must be a valid subdomain as defined by RFC 1123. All characters trailing the first \"/\" must be valid HTTP Path characters as defined by RFC 3986. The value cannot exceed 64 characters.\n\nThis field is alpha-level. The job controller accepts setting the field when the feature gate JobManagedBy is enabled (disabled by default).",
# >       "type": "string"
# >     },
# 52a57,60
# >     },
# >     "successPolicy": {
# >       "$ref": "#/definitions/io.k8s.api.batch.v1.SuccessPolicy",
# >       "description": "successPolicy specifies the policy when the Job can be declared as succeeded. If empty, the default behavior applies - the Job is declared as succeeded only when the number of succeeded pods equals to the completions. When the field is specified, it must be immutable and works only for the Indexed Jobs. Once the Job meets the SuccessPolicy, the lingering pods are terminated.\n\nThis field  is alpha-level. To use this field, you must enable the `JobSuccessPolicy` feature gate (disabled by default)."
# diff -r 1.29orig/defs/io.k8s.api.batch.v1.JobStatus.json 1.30orig/defs/io.k8s.api.batch.v1.JobStatus.json
# 5c5
# <       "description": "The number of pending and running pods.",
# ---
# >       "description": "The number of pending and running pods which are not terminating (without a deletionTimestamp). The value is zero for finished jobs.",
# 15c15
# <       "description": "Represents time when the job was completed. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC. The completion time is only set when the job finishes successfully."
# ---
# >       "description": "Represents time when the job was completed. It is not guaranteed to be set in happens-before order across separate operations. It is represented in RFC3339 form and is in UTC. The completion time is set when the job finishes successfully, and only then. The value cannot be updated or removed. The value indicates the same or later point in time as the startTime field."
# 18c18
# <       "description": "The latest available observations of an object's current state. When a Job fails, one of the conditions will have type \"Failed\" and status true. When a Job is suspended, one of the conditions will have type \"Suspended\" and status true; when the Job is resumed, the status of this condition will become false. When a Job is completed, one of the conditions will have type \"Complete\" and status true. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/",
# ---
# >       "description": "The latest available observations of an object's current state. When a Job fails, one of the conditions will have type \"Failed\" and status true. When a Job is suspended, one of the conditions will have type \"Suspended\" and status true; when the Job is resumed, the status of this condition will become false. When a Job is completed, one of the conditions will have type \"Complete\" and status true.\n\nA job is considered finished when it is in a terminal condition, either \"Complete\" or \"Failed\". A Job cannot have both the \"Complete\" and \"Failed\" conditions. Additionally, it cannot be in the \"Complete\" and \"FailureTarget\" conditions. The \"Complete\", \"Failed\" and \"FailureTarget\" conditions cannot be disabled.\n\nMore info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/",
# 28c28
# <       "description": "The number of pods which reached phase Failed.",
# ---
# >       "description": "The number of pods which reached phase Failed. The value increases monotonically.",
# 33c33
# <       "description": "FailedIndexes holds the failed indexes when backoffLimitPerIndex=true. The indexes are represented in the text format analogous as for the `completedIndexes` field, ie. they are kept as decimal integers separated by commas. The numbers are listed in increasing order. Three or more consecutive numbers are compressed and represented by the first and last element of the series, separated by a hyphen. For example, if the failed indexes are 1, 3, 4, 5 and 7, they are represented as \"1,3-5,7\". This field is beta-level. It can be used when the `JobBackoffLimitPerIndex` feature gate is enabled (enabled by default).",
# ---
# >       "description": "FailedIndexes holds the failed indexes when spec.backoffLimitPerIndex is set. The indexes are represented in the text format analogous as for the `completedIndexes` field, ie. they are kept as decimal integers separated by commas. The numbers are listed in increasing order. Three or more consecutive numbers are compressed and represented by the first and last element of the series, separated by a hyphen. For example, if the failed indexes are 1, 3, 4, 5 and 7, they are represented as \"1,3-5,7\". The set of failed indexes cannot overlap with the set of completed indexes.\n\nThis field is beta-level. It can be used when the `JobBackoffLimitPerIndex` feature gate is enabled (enabled by default).",
# 43c43
# <       "description": "Represents time when the job controller started processing a job. When a Job is created in the suspended state, this field is not set until the first time it is resumed. This field is reset every time a Job is resumed from suspension. It is represented in RFC3339 form and is in UTC."
# ---
# >       "description": "Represents time when the job controller started processing a job. When a Job is created in the suspended state, this field is not set until the first time it is resumed. This field is reset every time a Job is resumed from suspension. It is represented in RFC3339 form and is in UTC.\n\nOnce set, the field can only be removed when the job is suspended. The field cannot be modified while the job is unsuspended or finished."
# 46c46
# <       "description": "The number of pods which reached phase Succeeded.",
# ---
# >       "description": "The number of pods which reached phase Succeeded. The value increases monotonically for a given spec. However, it may decrease in reaction to scale down of elastic indexed jobs.",
# 57c57
# <       "description": "uncountedTerminatedPods holds the UIDs of Pods that have terminated but the job controller hasn't yet accounted for in the status counters.\n\nThe job controller creates pods with a finalizer. When a pod terminates (succeeded or failed), the controller does three steps to account for it in the job status:\n\n1. Add the pod UID to the arrays in this field. 2. Remove the pod finalizer. 3. Remove the pod UID from the arrays while increasing the corresponding\n    counter.\n\nOld jobs might not be tracked using this field, in which case the field remains null."
# ---
# >       "description": "uncountedTerminatedPods holds the UIDs of Pods that have terminated but the job controller hasn't yet accounted for in the status counters.\n\nThe job controller creates pods with a finalizer. When a pod terminates (succeeded or failed), the controller does three steps to account for it in the job status:\n\n1. Add the pod UID to the arrays in this field. 2. Remove the pod finalizer. 3. Remove the pod UID from the arrays while increasing the corresponding\n    counter.\n\nOld jobs might not be tracked using this field, in which case the field remains null. The structure is empty for finished jobs."
# diff -r 1.29orig/defs/io.k8s.api.core.v1.Capabilities.json 1.30orig/defs/io.k8s.api.core.v1.Capabilities.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 16c17,18
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.CephFSPersistentVolumeSource.json 1.30orig/defs/io.k8s.api.core.v1.CephFSPersistentVolumeSource.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.CephFSVolumeSource.json 1.30orig/defs/io.k8s.api.core.v1.CephFSVolumeSource.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.ComponentStatus.json 1.30orig/defs/io.k8s.api.core.v1.ComponentStatus.json
# 16a17,20
# >       "x-kubernetes-list-map-keys": [
# >         "type"
# >       ],
# >       "x-kubernetes-list-type": "map",
# diff -r 1.29orig/defs/io.k8s.api.core.v1.ConfigMapProjection.json 1.30orig/defs/io.k8s.api.core.v1.ConfigMapProjection.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.ConfigMapVolumeSource.json 1.30orig/defs/io.k8s.api.core.v1.ConfigMapVolumeSource.json
# 14c14,15
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.Container.json 1.30orig/defs/io.k8s.api.core.v1.Container.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 16c17,18
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 23a26,29
# >       "x-kubernetes-list-map-keys": [
# >         "name"
# >       ],
# >       "x-kubernetes-list-type": "map",
# 32c38,39
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 121a129,132
# >       "x-kubernetes-list-map-keys": [
# >         "devicePath"
# >       ],
# >       "x-kubernetes-list-type": "map",
# 130a142,145
# >       "x-kubernetes-list-map-keys": [
# >         "mountPath"
# >       ],
# >       "x-kubernetes-list-type": "map",
# diff -r 1.29orig/defs/io.k8s.api.core.v1.ContainerImage.json 1.30orig/defs/io.k8s.api.core.v1.ContainerImage.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.ContainerStatus.json 1.30orig/defs/io.k8s.api.core.v1.ContainerStatus.json
# 50a51,63
# >     },
# >     "volumeMounts": {
# >       "description": "Status of volume mounts.",
# >       "items": {
# >         "$ref": "#/definitions/io.k8s.api.core.v1.VolumeMountStatus"
# >       },
# >       "type": "array",
# >       "x-kubernetes-list-map-keys": [
# >         "mountPath"
# >       ],
# >       "x-kubernetes-list-type": "map",
# >       "x-kubernetes-patch-merge-key": "mountPath",
# >       "x-kubernetes-patch-strategy": "merge"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.DownwardAPIProjection.json 1.30orig/defs/io.k8s.api.core.v1.DownwardAPIProjection.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.DownwardAPIVolumeFile.json 1.30orig/defs/io.k8s.api.core.v1.DownwardAPIVolumeFile.json
# 6c6
# <       "description": "Required: Selects a field of the pod: only annotations, labels, name and namespace are supported."
# ---
# >       "description": "Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported."
# diff -r 1.29orig/defs/io.k8s.api.core.v1.DownwardAPIVolumeSource.json 1.30orig/defs/io.k8s.api.core.v1.DownwardAPIVolumeSource.json
# 14c14,15
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.EndpointSubset.json 1.30orig/defs/io.k8s.api.core.v1.EndpointSubset.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 16c17,18
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 23c25,26
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.Endpoints.json 1.30orig/defs/io.k8s.api.core.v1.Endpoints.json
# 27c27,28
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.EphemeralContainer.json 1.30orig/defs/io.k8s.api.core.v1.EphemeralContainer.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 16c17,18
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 23a26,29
# >       "x-kubernetes-list-map-keys": [
# >         "name"
# >       ],
# >       "x-kubernetes-list-type": "map",
# 32c38,39
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 125a133,136
# >       "x-kubernetes-list-map-keys": [
# >         "devicePath"
# >       ],
# >       "x-kubernetes-list-type": "map",
# 134a146,149
# >       "x-kubernetes-list-map-keys": [
# >         "mountPath"
# >       ],
# >       "x-kubernetes-list-type": "map",
# diff -r 1.29orig/defs/io.k8s.api.core.v1.ExecAction.json 1.30orig/defs/io.k8s.api.core.v1.ExecAction.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.FCVolumeSource.json 1.30orig/defs/io.k8s.api.core.v1.FCVolumeSource.json
# 22c22,23
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 29c30,31
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.HTTPGetAction.json 1.30orig/defs/io.k8s.api.core.v1.HTTPGetAction.json
# 13c13,14
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.HostAlias.json 1.30orig/defs/io.k8s.api.core.v1.HostAlias.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.ISCSIPersistentVolumeSource.json 1.30orig/defs/io.k8s.api.core.v1.ISCSIPersistentVolumeSource.json
# 38c38,39
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.ISCSIVolumeSource.json 1.30orig/defs/io.k8s.api.core.v1.ISCSIVolumeSource.json
# 38c38,39
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.LimitRangeSpec.json 1.30orig/defs/io.k8s.api.core.v1.LimitRangeSpec.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.LoadBalancerStatus.json 1.30orig/defs/io.k8s.api.core.v1.LoadBalancerStatus.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.NamespaceSpec.json 1.30orig/defs/io.k8s.api.core.v1.NamespaceSpec.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.NamespaceStatus.json 1.30orig/defs/io.k8s.api.core.v1.NamespaceStatus.json
# 9a10,13
# >       "x-kubernetes-list-map-keys": [
# >         "type"
# >       ],
# >       "x-kubernetes-list-type": "map",
# diff -r 1.29orig/defs/io.k8s.api.core.v1.NodeAffinity.json 1.30orig/defs/io.k8s.api.core.v1.NodeAffinity.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.NodeSelector.json 1.30orig/defs/io.k8s.api.core.v1.NodeSelector.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.NodeSelectorRequirement.json 1.30orig/defs/io.k8s.api.core.v1.NodeSelectorRequirement.json
# 17c17,18
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.NodeSelectorTerm.json 1.30orig/defs/io.k8s.api.core.v1.NodeSelectorTerm.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 16c17,18
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.NodeSpec.json 1.30orig/defs/io.k8s.api.core.v1.NodeSpec.json
# 21a22
# >       "x-kubernetes-list-type": "set",
# 33c34,35
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"

# Only in 1.30orig/defs: io.k8s.api.core.v1.NodeRuntimeHandler.json
# Only in 1.30orig/defs: io.k8s.api.core.v1.NodeRuntimeHandlerFeatures.json

# diff -r 1.29orig/defs/io.k8s.api.core.v1.NodeStatus.json 1.30orig/defs/io.k8s.api.core.v1.NodeStatus.json
# 9a10,13
# >       "x-kubernetes-list-map-keys": [
# >         "type"
# >       ],
# >       "x-kubernetes-list-type": "map",
# 32a37,40
# >       "x-kubernetes-list-map-keys": [
# >         "type"
# >       ],
# >       "x-kubernetes-list-type": "map",
# 49c57,58
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 58a68,75
# >     "runtimeHandlers": {
# >       "description": "The available runtime handlers.",
# >       "items": {
# >         "$ref": "#/definitions/io.k8s.api.core.v1.NodeRuntimeHandler"
# >       },
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# >     },
# 64c81,82
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 71c89,90
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.PersistentVolumeClaimCondition.json 1.30orig/defs/io.k8s.api.core.v1.PersistentVolumeClaimCondition.json
# 17c17
# <       "description": "reason is a unique, this should be a short, machine understandable string that gives the reason for condition's last transition. If it reports \"ResizeStarted\" that means the underlying persistent volume is being resized.",
# ---
# >       "description": "reason is a unique, this should be a short, machine understandable string that gives the reason for condition's last transition. If it reports \"Resizing\" that means the underlying persistent volume is being resized.",
# diff -r 1.29orig/defs/io.k8s.api.core.v1.PersistentVolumeClaimSpec.json 1.30orig/defs/io.k8s.api.core.v1.PersistentVolumeClaimSpec.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 32c33
# <       "description": "volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim. If specified, the CSI driver will create or update the volume with the attributes defined in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName, it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass will be applied to the claim but it's not allowed to reset this field to empty string once it is set. If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass will be set by the persistentvolume controller if it exists. If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource exists. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#volumeattributesclass (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.",
# ---
# >       "description": "volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim. If specified, the CSI driver will create or update the volume with the attributes defined in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName, it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass will be applied to the claim but it's not allowed to reset this field to empty string once it is set. If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass will be set by the persistentvolume controller if it exists. If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource exists. More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/ (Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.",
# diff -r 1.29orig/defs/io.k8s.api.core.v1.PersistentVolumeClaimStatus.json 1.30orig/defs/io.k8s.api.core.v1.PersistentVolumeClaimStatus.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 34c35
# <       "description": "conditions is the current Condition of persistent volume claim. If underlying persistent volume is being resized then the Condition will be set to 'ResizeStarted'.",
# ---
# >       "description": "conditions is the current Condition of persistent volume claim. If underlying persistent volume is being resized then the Condition will be set to 'Resizing'.",
# 38a40,43
# >       "x-kubernetes-list-map-keys": [
# >         "type"
# >       ],
# >       "x-kubernetes-list-type": "map",
# diff -r 1.29orig/defs/io.k8s.api.core.v1.PersistentVolumeSpec.json 1.30orig/defs/io.k8s.api.core.v1.PersistentVolumeSpec.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 84c85,86
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.PersistentVolumeStatus.json 1.30orig/defs/io.k8s.api.core.v1.PersistentVolumeStatus.json
# 6c6
# <       "description": "lastPhaseTransitionTime is the time the phase transitioned from one to another and automatically resets to current time everytime a volume phase transitions. This is an alpha field and requires enabling PersistentVolumeLastPhaseTransitionTime feature."
# ---
# >       "description": "lastPhaseTransitionTime is the time the phase transitioned from one to another and automatically resets to current time everytime a volume phase transitions. This is a beta field and requires the PersistentVolumeLastPhaseTransitionTime feature to be enabled (enabled by default)."
# diff -r 1.29orig/defs/io.k8s.api.core.v1.PodAffinity.json 1.30orig/defs/io.k8s.api.core.v1.PodAffinity.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 16c17,18
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.PodAffinityTerm.json 1.30orig/defs/io.k8s.api.core.v1.PodAffinityTerm.json
# 9c9
# <       "description": "MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with `LabelSelector` as `key in (value)` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector. Also, MatchLabelKeys cannot be set when LabelSelector isn't set. This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.",
# ---
# >       "description": "MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both matchLabelKeys and labelSelector. Also, matchLabelKeys cannot be set when labelSelector isn't set. This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.",
# 17c17
# <       "description": "MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with `LabelSelector` as `key notin (value)` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both MismatchLabelKeys and LabelSelector. Also, MismatchLabelKeys cannot be set when LabelSelector isn't set. This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.",
# ---
# >       "description": "MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration. The keys are used to lookup values from the incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)` to select the group of existing pods which pods will be taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist in both mismatchLabelKeys and labelSelector. Also, mismatchLabelKeys cannot be set when labelSelector isn't set. This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.",
# 33c33,34
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.PodAntiAffinity.json 1.30orig/defs/io.k8s.api.core.v1.PodAntiAffinity.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 16c17,18
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.PodDNSConfig.json 1.30orig/defs/io.k8s.api.core.v1.PodDNSConfig.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 16c17,18
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 23c25,26
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"

# Only in 1.30orig/defs: io.k8s.api.core.v1.AppArmorProfile.json
# diff -r 1.29orig/defs/io.k8s.api.core.v1.PodSecurityContext.json 1.30orig/defs/io.k8s.api.core.v1.PodSecurityContext.json
# 3a4,7
# >     "appArmorProfile": {
# >       "$ref": "#/definitions/io.k8s.api.core.v1.AppArmorProfile",
# >       "description": "appArmorProfile is the AppArmor options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows."
# >     },
# 41c45,46
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 48c53,54
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.PodSpec.json 1.30orig/defs/io.k8s.api.core.v1.PodSpec.json
# 22a23,26
# >       "x-kubernetes-list-map-keys": [
# >         "name"
# >       ],
# >       "x-kubernetes-list-type": "map",
# 43a48,51
# >       "x-kubernetes-list-map-keys": [
# >         "name"
# >       ],
# >       "x-kubernetes-list-type": "map",
# 48c56
# <       "description": "HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified. This is only valid for non-hostNetwork pods.",
# ---
# >       "description": "HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.",
# 52a61,64
# >       "x-kubernetes-list-map-keys": [
# >         "ip"
# >       ],
# >       "x-kubernetes-list-type": "map",
# 81a94,97
# >       "x-kubernetes-list-map-keys": [
# >         "name"
# >       ],
# >       "x-kubernetes-list-type": "map",
# 90a107,110
# >       "x-kubernetes-list-map-keys": [
# >         "name"
# >       ],
# >       "x-kubernetes-list-type": "map",
# 108c128
# <       "description": "Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set.\n\nIf the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions\n\nIf the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup"
# ---
# >       "description": "Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set.\n\nIf the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions\n\nIf the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.securityContext.appArmorProfile - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.containers[*].securityContext.appArmorProfile - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup"
# 135c155,156
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 163c184
# <       "description": "SchedulingGates is an opaque list of values that if specified will block scheduling the pod. If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the scheduler will not attempt to schedule the pod.\n\nSchedulingGates can only be set at pod creation time, and be removed only afterwards.\n\nThis is a beta feature enabled by the PodSchedulingReadiness feature gate.",
# ---
# >       "description": "SchedulingGates is an opaque list of values that if specified will block scheduling the pod. If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the scheduler will not attempt to schedule the pod.\n\nSchedulingGates can only be set at pod creation time, and be removed only afterwards.",
# 180c201
# <       "description": "DeprecatedServiceAccount is a depreciated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.",
# ---
# >       "description": "DeprecatedServiceAccount is a deprecated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.",
# 209c230,231
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 230a253,256
# >       "x-kubernetes-list-map-keys": [
# >         "name"
# >       ],
# >       "x-kubernetes-list-type": "map",
# diff -r 1.29orig/defs/io.k8s.api.core.v1.PodStatus.json 1.30orig/defs/io.k8s.api.core.v1.PodStatus.json
# 9a10,13
# >       "x-kubernetes-list-map-keys": [
# >         "type"
# >       ],
# >       "x-kubernetes-list-type": "map",
# 18c22,23
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 25c30,31
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 46c52,53
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 69a77,80
# >       "x-kubernetes-list-map-keys": [
# >         "ip"
# >       ],
# >       "x-kubernetes-list-type": "map",
# diff -r 1.29orig/defs/io.k8s.api.core.v1.ProjectedVolumeSource.json 1.30orig/defs/io.k8s.api.core.v1.ProjectedVolumeSource.json
# 14c14,15
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.RBDPersistentVolumeSource.json 1.30orig/defs/io.k8s.api.core.v1.RBDPersistentVolumeSource.json
# 21c21,22
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.RBDVolumeSource.json 1.30orig/defs/io.k8s.api.core.v1.RBDVolumeSource.json
# 21c21,22
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.ReplicationControllerStatus.json 1.30orig/defs/io.k8s.api.core.v1.ReplicationControllerStatus.json
# 14a15,18
# >       "x-kubernetes-list-map-keys": [
# >         "type"
# >       ],
# >       "x-kubernetes-list-type": "map",
# diff -r 1.29orig/defs/io.k8s.api.core.v1.ResourceQuotaSpec.json 1.30orig/defs/io.k8s.api.core.v1.ResourceQuotaSpec.json
# 20c20,21
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.ScopeSelector.json 1.30orig/defs/io.k8s.api.core.v1.ScopeSelector.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.ScopedResourceSelectorRequirement.json 1.30orig/defs/io.k8s.api.core.v1.ScopedResourceSelectorRequirement.json
# 17c17,18
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.SecretProjection.json 1.30orig/defs/io.k8s.api.core.v1.SecretProjection.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.SecretVolumeSource.json 1.30orig/defs/io.k8s.api.core.v1.SecretVolumeSource.json
# 14c14,15
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.SecurityContext.json 1.30orig/defs/io.k8s.api.core.v1.SecurityContext.json
# 7a8,11
# >     "appArmorProfile": {
# >       "$ref": "#/definitions/io.k8s.api.core.v1.AppArmorProfile",
# >       "description": "appArmorProfile is the AppArmor options to use by this container. If set, this profile overrides the pod's appArmorProfile. Note that this field cannot be set when spec.os.name is windows."
# >     },
# diff -r 1.29orig/defs/io.k8s.api.core.v1.ServiceAccount.json 1.30orig/defs/io.k8s.api.core.v1.ServiceAccount.json
# 20c20,21
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 38a40,43
# >       "x-kubernetes-list-map-keys": [
# >         "name"
# >       ],
# >       "x-kubernetes-list-type": "map",
# diff -r 1.29orig/defs/io.k8s.api.core.v1.ServiceSpec.json 1.30orig/defs/io.k8s.api.core.v1.ServiceSpec.json
# 25c25,26
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 69c70,71
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 103a106,109
# >     },
# >     "trafficDistribution": {
# >       "description": "TrafficDistribution offers a way to express preferences for how traffic is distributed to Service endpoints. Implementations can use this field as a hint, but are not required to guarantee strict adherence. If the field is not set, the implementation will apply its default routing strategy. If set to \"PreferClose\", implementations should prioritize endpoints that are topologically close (e.g., same zone).",
# >       "type": "string"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.TopologySelectorLabelRequirement.json 1.30orig/defs/io.k8s.api.core.v1.TopologySelectorLabelRequirement.json
# 13c13,14
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.TopologySelectorTerm.json 1.30orig/defs/io.k8s.api.core.v1.TopologySelectorTerm.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.core.v1.TopologySpreadConstraint.json 1.30orig/defs/io.k8s.api.core.v1.TopologySpreadConstraint.json
# 22c22
# <       "description": "MinDomains indicates a minimum number of eligible domains. When the number of eligible domains with matching topology keys is less than minDomains, Pod Topology Spread treats \"global minimum\" as 0, and then the calculation of Skew is performed. And when the number of eligible domains with matching topology keys equals or greater than minDomains, this value has no effect on scheduling. As a result, when the number of eligible domains is less than minDomains, scheduler won't schedule more than maxSkew Pods to those domains. If value is nil, the constraint behaves as if MinDomains is equal to 1. Valid values are integers greater than 0. When value is not nil, WhenUnsatisfiable must be DoNotSchedule.\n\nFor example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same labelSelector spread as 2/2/2: | zone1 | zone2 | zone3 | |  P P  |  P P  |  P P  | The number of domains is less than 5(MinDomains), so \"global minimum\" is treated as 0. In this situation, new pod with the same labelSelector cannot be scheduled, because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones, it will violate MaxSkew.\n\nThis is a beta field and requires the MinDomainsInPodTopologySpread feature gate to be enabled (enabled by default).",
# ---
# >       "description": "MinDomains indicates a minimum number of eligible domains. When the number of eligible domains with matching topology keys is less than minDomains, Pod Topology Spread treats \"global minimum\" as 0, and then the calculation of Skew is performed. And when the number of eligible domains with matching topology keys equals or greater than minDomains, this value has no effect on scheduling. As a result, when the number of eligible domains is less than minDomains, scheduler won't schedule more than maxSkew Pods to those domains. If value is nil, the constraint behaves as if MinDomains is equal to 1. Valid values are integers greater than 0. When value is not nil, WhenUnsatisfiable must be DoNotSchedule.\n\nFor example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same labelSelector spread as 2/2/2: | zone1 | zone2 | zone3 | |  P P  |  P P  |  P P  | The number of domains is less than 5(MinDomains), so \"global minimum\" is treated as 0. In this situation, new pod with the same labelSelector cannot be scheduled, because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones, it will violate MaxSkew.",
# diff -r 1.29orig/defs/io.k8s.api.core.v1.VolumeMount.json 1.30orig/defs/io.k8s.api.core.v1.VolumeMount.json
# 9c9
# <       "description": "mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.",
# ---
# >       "description": "mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10. When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified (which defaults to None).",
# 18a19,22
# >     },
# >     "recursiveReadOnly": {
# >       "description": "RecursiveReadOnly specifies whether read-only mounts should be handled recursively.\n\nIf ReadOnly is false, this field has no meaning and must be unspecified.\n\nIf ReadOnly is true, and this field is set to Disabled, the mount is not made recursively read-only.  If this field is set to IfPossible, the mount is made recursively read-only, if it is supported by the container runtime.  If this field is set to Enabled, the mount is made recursively read-only if it is supported by the container runtime, otherwise the pod will not be started and an error will be generated to indicate the reason.\n\nIf this field is set to IfPossible or Enabled, MountPropagation must be set to None (or be unspecified, which defaults to None).\n\nIf this field is not specified, it is treated as an equivalent of Disabled.",
# >       "type": "string"

# Only in 1.30orig/defs: io.k8s.api.core.v1.VolumeMountStatus.json

# diff -r 1.29orig/defs/io.k8s.api.networking.v1.IPBlock.json 1.30orig/defs/io.k8s.api.networking.v1.IPBlock.json
# 13c13,14
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.networking.v1.IngressLoadBalancerStatus.json 1.30orig/defs/io.k8s.api.networking.v1.IngressLoadBalancerStatus.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.networking.v1.NetworkPolicyEgressRule.json 1.30orig/defs/io.k8s.api.networking.v1.NetworkPolicyEgressRule.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 16c17,18
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.networking.v1.NetworkPolicyIngressRule.json 1.30orig/defs/io.k8s.api.networking.v1.NetworkPolicyIngressRule.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 16c17,18
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.networking.v1.NetworkPolicySpec.json 1.30orig/defs/io.k8s.api.networking.v1.NetworkPolicySpec.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 16c17,18
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 27c29,30
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.networking.v1alpha1.IPAddressSpec.json 1.30orig/defs/io.k8s.api.networking.v1alpha1.IPAddressSpec.json
# 8a9,11
# >   "required": [
# >     "parentRef"
# >   ],
# diff -r 1.29orig/defs/io.k8s.api.networking.v1alpha1.ParentReference.json 1.30orig/defs/io.k8s.api.networking.v1alpha1.ParentReference.json
# 20a21,24
# >   "required": [
# >     "resource",
# >     "name"
# >   ],
# diff -r 1.29orig/defs/io.k8s.api.networking.v1alpha1.ServiceCIDRSpec.json 1.30orig/defs/io.k8s.api.networking.v1alpha1.ServiceCIDRSpec.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.rbac.v1.AggregationRule.json 1.30orig/defs/io.k8s.api.rbac.v1.AggregationRule.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.rbac.v1.ClusterRole.json 1.30orig/defs/io.k8s.api.rbac.v1.ClusterRole.json
# 31c31,32
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.rbac.v1.ClusterRoleBinding.json 1.30orig/defs/io.k8s.api.rbac.v1.ClusterRoleBinding.json
# 31c31,32
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.rbac.v1.PolicyRule.json 1.30orig/defs/io.k8s.api.rbac.v1.PolicyRule.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 16c17,18
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 23c25,26
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 30c33,34
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 37c41,42
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.rbac.v1.Role.json 1.30orig/defs/io.k8s.api.rbac.v1.Role.json
# 27c27,28
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.rbac.v1.RoleBinding.json 1.30orig/defs/io.k8s.api.rbac.v1.RoleBinding.json
# 31c31,32
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"

# diff -r 1.29orig/defs/io.k8s.api.resource.v1alpha2.ResourceClaimStatus.json 1.30orig/defs/io.k8s.api.resource.v1alpha2.ResourceClaimStatus.json
# 25c25,27
# <       "x-kubernetes-list-type": "map"
# ---
# >       "x-kubernetes-list-type": "map",
# >       "x-kubernetes-patch-merge-key": "uid",
# >       "x-kubernetes-patch-strategy": "merge"
# diff -r 1.29orig/defs/io.k8s.api.resource.v1alpha2.ResourceClass.json 1.30orig/defs/io.k8s.api.resource.v1alpha2.ResourceClass.json
# 29a30,33
# >     "structuredParameters": {
# >       "description": "If and only if allocation of claims using this class is handled via structured parameters, then StructuredParameters must be set to true.",
# >       "type": "boolean"
# >     },
# diff -r 1.29orig/defs/io.k8s.api.resource.v1alpha2.ResourceHandle.json 1.30orig/defs/io.k8s.api.resource.v1alpha2.ResourceHandle.json
# 10a11,14
# >     },
# >     "structuredData": {
# >       "$ref": "#/definitions/io.k8s.api.resource.v1alpha2.StructuredResourceHandle",
# >       "description": "If StructuredData is set, then it needs to be used instead of Data."
# diff -r 1.29orig/defs/io.k8s.api.storage.v1.CSIDriverSpec.json 1.30orig/defs/io.k8s.api.storage.v1.CSIDriverSpec.json
# 9c9
# <       "description": "fsGroupPolicy defines if the underlying volume supports changing ownership and permission of the volume before being mounted. Refer to the specific FSGroupPolicy values for additional details.\n\nThis field is immutable.\n\nDefaults to ReadWriteOnceWithFSType, which will examine each volume to determine if Kubernetes should modify ownership and permissions of the volume. With the default policy the defined fsGroup will only be applied if a fstype is defined and the volume's access mode contains ReadWriteOnce.",
# ---
# >       "description": "fsGroupPolicy defines if the underlying volume supports changing ownership and permission of the volume before being mounted. Refer to the specific FSGroupPolicy values for additional details.\n\nThis field was immutable in Kubernetes < 1.29 and now is mutable.\n\nDefaults to ReadWriteOnceWithFSType, which will examine each volume to determine if Kubernetes should modify ownership and permissions of the volume. With the default policy the defined fsGroup will only be applied if a fstype is defined and the volume's access mode contains ReadWriteOnce.",
# 13c13
# <       "description": "podInfoOnMount indicates this CSI volume driver requires additional pod information (like podName, podUID, etc.) during mount operations, if set to true. If set to false, pod information will not be passed on mount. Default is false.\n\nThe CSI driver specifies podInfoOnMount as part of driver deployment. If true, Kubelet will pass pod information as VolumeContext in the CSI NodePublishVolume() calls. The CSI driver is responsible for parsing and validating the information passed in as VolumeContext.\n\nThe following VolumeContext will be passed if podInfoOnMount is set to true. This list might grow, but the prefix will be used. \"csi.storage.k8s.io/pod.name\": pod.Name \"csi.storage.k8s.io/pod.namespace\": pod.Namespace \"csi.storage.k8s.io/pod.uid\": string(pod.UID) \"csi.storage.k8s.io/ephemeral\": \"true\" if the volume is an ephemeral inline volume\n                                defined by a CSIVolumeSource, otherwise \"false\"\n\n\"csi.storage.k8s.io/ephemeral\" is a new feature in Kubernetes 1.16. It is only required for drivers which support both the \"Persistent\" and \"Ephemeral\" VolumeLifecycleMode. Other drivers can leave pod info disabled and/or ignore this field. As Kubernetes 1.15 doesn't support this field, drivers can only support one mode when deployed on such a cluster and the deployment determines which mode that is, for example via a command line parameter of the driver.\n\nThis field is immutable.",
# ---
# >       "description": "podInfoOnMount indicates this CSI volume driver requires additional pod information (like podName, podUID, etc.) during mount operations, if set to true. If set to false, pod information will not be passed on mount. Default is false.\n\nThe CSI driver specifies podInfoOnMount as part of driver deployment. If true, Kubelet will pass pod information as VolumeContext in the CSI NodePublishVolume() calls. The CSI driver is responsible for parsing and validating the information passed in as VolumeContext.\n\nThe following VolumeContext will be passed if podInfoOnMount is set to true. This list might grow, but the prefix will be used. \"csi.storage.k8s.io/pod.name\": pod.Name \"csi.storage.k8s.io/pod.namespace\": pod.Namespace \"csi.storage.k8s.io/pod.uid\": string(pod.UID) \"csi.storage.k8s.io/ephemeral\": \"true\" if the volume is an ephemeral inline volume\n                                defined by a CSIVolumeSource, otherwise \"false\"\n\n\"csi.storage.k8s.io/ephemeral\" is a new feature in Kubernetes 1.16. It is only required for drivers which support both the \"Persistent\" and \"Ephemeral\" VolumeLifecycleMode. Other drivers can leave pod info disabled and/or ignore this field. As Kubernetes 1.15 doesn't support this field, drivers can only support one mode when deployed on such a cluster and the deployment determines which mode that is, for example via a command line parameter of the driver.\n\nThis field was immutable in Kubernetes < 1.29 and now is mutable.",
# diff -r 1.29orig/defs/io.k8s.api.storage.v1.CSINodeDriver.json 1.30orig/defs/io.k8s.api.storage.v1.CSINodeDriver.json
# 21c21,22
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.api.storage.v1.CSINodeSpec.json 1.30orig/defs/io.k8s.api.storage.v1.CSINodeSpec.json
# 9a10,13
# >       "x-kubernetes-list-map-keys": [
# >         "name"
# >       ],
# >       "x-kubernetes-list-type": "map",
# diff -r 1.29orig/defs/io.k8s.api.storage.v1.CSIStorageCapacityList.json 1.30orig/defs/io.k8s.api.storage.v1.CSIStorageCapacityList.json
# 16,20c16
# <       "type": "array",
# <       "x-kubernetes-list-map-keys": [
# <         "name"
# <       ],
# <       "x-kubernetes-list-type": "map"
# ---
# >       "type": "array"
# diff -r 1.29orig/defs/io.k8s.api.storage.v1.StorageClass.json 1.30orig/defs/io.k8s.api.storage.v1.StorageClass.json
# 39c39,40
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"

# diff -r 1.29orig/defs/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinitionNames.json 1.30orig/defs/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinitionNames.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 28c29,30
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinitionSpec.json 1.30orig/defs/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinitionSpec.json
# 29c29,30
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinitionStatus.json 1.30orig/defs/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinitionStatus.json
# 24c24,25
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinitionVersion.json 1.30orig/defs/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.CustomResourceDefinitionVersion.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 25a27,34
# >     },
# >     "selectableFields": {
# >       "description": "selectableFields specifies paths to fields that may be used as field selectors. A maximum of 8 selectable fields are allowed. See https://kubernetes.io/docs/concepts/overview/working-with-objects/field-selectors",
# >       "items": {
# >         "$ref": "#/definitions/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.SelectableField"
# >       },
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# Only in 1.30orig/defs: io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.SelectableField.json

# diff -r 1.29orig/defs/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.WebhookConversion.json 1.30orig/defs/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.WebhookConversion.json
# 13c13,14
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.apimachinery.pkg.apis.meta.v1.APIGroup.json 1.30orig/defs/io.k8s.apimachinery.pkg.apis.meta.v1.APIGroup.json
# 31c31,32
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 38c39,40
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.apimachinery.pkg.apis.meta.v1.APIGroupList.json 1.30orig/defs/io.k8s.apimachinery.pkg.apis.meta.v1.APIGroupList.json
# 16c16,17
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.apimachinery.pkg.apis.meta.v1.APIResource.json 1.30orig/defs/io.k8s.apimachinery.pkg.apis.meta.v1.APIResource.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 32c33,34
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.apimachinery.pkg.apis.meta.v1.APIResourceList.json 1.30orig/defs/io.k8s.apimachinery.pkg.apis.meta.v1.APIResourceList.json
# 27c27,28
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.apimachinery.pkg.apis.meta.v1.APIVersions.json 1.30orig/defs/io.k8s.apimachinery.pkg.apis.meta.v1.APIVersions.json
# 23c23,24
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 30c31,32
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions.json 1.30orig/defs/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions.json
# 13c13,14
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 327a329,333
# >     },
# >     {
# >       "group": "storagemigration.k8s.io",
# >       "kind": "DeleteOptions",
# >       "version": "v1alpha1"
# diff -r 1.29orig/defs/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector.json 1.30orig/defs/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement.json 1.30orig/defs/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement.json
# 17c17,18
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta.json 1.30orig/defs/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta.json
# 29a30
# >       "x-kubernetes-list-type": "set",
# 53c54,55
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# 68a71,74
# >       "x-kubernetes-list-map-keys": [
# >         "uid"
# >       ],
# >       "x-kubernetes-list-type": "map",
# diff -r 1.29orig/defs/io.k8s.apimachinery.pkg.apis.meta.v1.Status.json 1.30orig/defs/io.k8s.apimachinery.pkg.apis.meta.v1.Status.json
# 15c15,16
# <       "description": "Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type."
# ---
# >       "description": "Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.",
# >       "x-kubernetes-list-type": "atomic"
# diff -r 1.29orig/defs/io.k8s.apimachinery.pkg.apis.meta.v1.StatusDetails.json 1.30orig/defs/io.k8s.apimachinery.pkg.apis.meta.v1.StatusDetails.json
# 9c9,10
# <       "type": "array"
# ---
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
diff -r 1.29orig/defs/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent.json 1.30orig/defs/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent.json
306a307,311
>     },
>     {
>       "group": "storagemigration.k8s.io",
>       "kind": "WatchEvent",
>       "version": "v1alpha1"


