## Remove autoscaling/v2beta1
# Only in 1.24orig/defs: io.k8s.api.autoscaling.v2beta1.ContainerResourceMetricSource.json
# Only in 1.24orig/defs: io.k8s.api.autoscaling.v2beta1.ContainerResourceMetricStatus.json
# Only in 1.24orig/defs: io.k8s.api.autoscaling.v2beta1.CrossVersionObjectReference.json
# Only in 1.24orig/defs: io.k8s.api.autoscaling.v2beta1.ExternalMetricSource.json
# Only in 1.24orig/defs: io.k8s.api.autoscaling.v2beta1.ExternalMetricStatus.json
# Only in 1.24orig/defs: io.k8s.api.autoscaling.v2beta1.HorizontalPodAutoscaler.json
# Only in 1.24orig/defs: io.k8s.api.autoscaling.v2beta1.HorizontalPodAutoscalerCondition.json
# Only in 1.24orig/defs: io.k8s.api.autoscaling.v2beta1.HorizontalPodAutoscalerList.json
# Only in 1.24orig/defs: io.k8s.api.autoscaling.v2beta1.HorizontalPodAutoscalerSpec.json
# Only in 1.24orig/defs: io.k8s.api.autoscaling.v2beta1.HorizontalPodAutoscalerStatus.json
# Only in 1.24orig/defs: io.k8s.api.autoscaling.v2beta1.MetricSpec.json
# Only in 1.24orig/defs: io.k8s.api.autoscaling.v2beta1.MetricStatus.json
# Only in 1.24orig/defs: io.k8s.api.autoscaling.v2beta1.ObjectMetricSource.json
# Only in 1.24orig/defs: io.k8s.api.autoscaling.v2beta1.ObjectMetricStatus.json
# Only in 1.24orig/defs: io.k8s.api.autoscaling.v2beta1.PodsMetricSource.json
# Only in 1.24orig/defs: io.k8s.api.autoscaling.v2beta1.PodsMetricStatus.json
# Only in 1.24orig/defs: io.k8s.api.autoscaling.v2beta1.ResourceMetricSource.json
# Only in 1.24orig/defs: io.k8s.api.autoscaling.v2beta1.ResourceMetricStatus.json

## Remove batch/v1beta1
# Only in 1.24orig/defs: io.k8s.api.batch.v1beta1.CronJob.json
# Only in 1.24orig/defs: io.k8s.api.batch.v1beta1.CronJobList.json
# Only in 1.24orig/defs: io.k8s.api.batch.v1beta1.CronJobSpec.json
# Only in 1.24orig/defs: io.k8s.api.batch.v1beta1.CronJobStatus.json
# Only in 1.24orig/defs: io.k8s.api.batch.v1beta1.JobTemplateSpec.json

## Remove discovery/v1beta1
# Only in 1.24orig/defs: io.k8s.api.discovery.v1beta1.Endpoint.json
# Only in 1.24orig/defs: io.k8s.api.discovery.v1beta1.EndpointConditions.json
# Only in 1.24orig/defs: io.k8s.api.discovery.v1beta1.EndpointHints.json
# Only in 1.24orig/defs: io.k8s.api.discovery.v1beta1.EndpointPort.json
# Only in 1.24orig/defs: io.k8s.api.discovery.v1beta1.EndpointSlice.json
# Only in 1.24orig/defs: io.k8s.api.discovery.v1beta1.EndpointSliceList.json
# Only in 1.24orig/defs: io.k8s.api.discovery.v1beta1.ForZone.json

## Remove events/v1beta1
# Only in 1.24orig/defs: io.k8s.api.events.v1beta1.Event.json
# Only in 1.24orig/defs: io.k8s.api.events.v1beta1.EventList.json
# Only in 1.24orig/defs: io.k8s.api.events.v1beta1.EventSeries.json


## Remove node/v1beta1
# Only in 1.24orig/defs: io.k8s.api.node.v1beta1.Overhead.json
# Only in 1.24orig/defs: io.k8s.api.node.v1beta1.RuntimeClass.json
# Only in 1.24orig/defs: io.k8s.api.node.v1beta1.RuntimeClassList.json
# Only in 1.24orig/defs: io.k8s.api.node.v1beta1.Scheduling.json

## Remove policy/v1beta1
# Only in 1.24orig/defs: io.k8s.api.policy.v1beta1.AllowedCSIDriver.json
# Only in 1.24orig/defs: io.k8s.api.policy.v1beta1.AllowedFlexVolume.json
# Only in 1.24orig/defs: io.k8s.api.policy.v1beta1.AllowedHostPath.json
# Only in 1.24orig/defs: io.k8s.api.policy.v1beta1.FSGroupStrategyOptions.json
# Only in 1.24orig/defs: io.k8s.api.policy.v1beta1.HostPortRange.json
# Only in 1.24orig/defs: io.k8s.api.policy.v1beta1.IDRange.json
# Only in 1.24orig/defs: io.k8s.api.policy.v1beta1.PodDisruptionBudget.json
# Only in 1.24orig/defs: io.k8s.api.policy.v1beta1.PodDisruptionBudgetList.json
# Only in 1.24orig/defs: io.k8s.api.policy.v1beta1.PodDisruptionBudgetSpec.json
# Only in 1.24orig/defs: io.k8s.api.policy.v1beta1.PodDisruptionBudgetStatus.json
# Only in 1.24orig/defs: io.k8s.api.policy.v1beta1.PodSecurityPolicy.json
# Only in 1.24orig/defs: io.k8s.api.policy.v1beta1.PodSecurityPolicyList.json
# Only in 1.24orig/defs: io.k8s.api.policy.v1beta1.PodSecurityPolicySpec.json
# Only in 1.24orig/defs: io.k8s.api.policy.v1beta1.RunAsGroupStrategyOptions.json
# Only in 1.24orig/defs: io.k8s.api.policy.v1beta1.RunAsUserStrategyOptions.json
# Only in 1.24orig/defs: io.k8s.api.policy.v1beta1.RuntimeClassStrategyOptions.json
# Only in 1.24orig/defs: io.k8s.api.policy.v1beta1.SELinuxStrategyOptions.json
# Only in 1.24orig/defs: io.k8s.api.policy.v1beta1.SupplementalGroupsStrategyOptions.json

# diff -r 1.24orig/defs/io.k8s.api.authentication.v1.TokenRequestSpec.json 1.25orig/defs/io.k8s.api.authentication.v1.TokenRequestSpec.json
# 5c5
# <       "description": "Audiences are the intendend audiences of the token. A recipient of a token must identitfy themself with an identifier in the list of audiences of the token, and otherwise should reject the token. A token issued for multiple audiences may be used to authenticate against any of the audiences listed but implies a high degree of trust between the target audiences.",
# ---
# >       "description": "Audiences are the intendend audiences of the token. A recipient of a token must identify themself with an identifier in the list of audiences of the token, and otherwise should reject the token. A token issued for multiple audiences may be used to authenticate against any of the audiences listed but implies a high degree of trust between the target audiences.",

# diff -r 1.24orig/defs/io.k8s.api.core.v1.CSIPersistentVolumeSource.json 1.25orig/defs/io.k8s.api.core.v1.CSIPersistentVolumeSource.json
# 6c6
# <       "description": "controllerExpandSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI ControllerExpandVolume call. This is an alpha field and requires enabling ExpandCSIVolumes feature gate. This field is optional, and may be empty if no secret is required. If the secret object contains more than one secret, all secrets are passed."
# ---
# >       "description": "controllerExpandSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI ControllerExpandVolume call. This is an beta field and requires enabling ExpandCSIVolumes feature gate. This field is optional, and may be empty if no secret is required. If the secret object contains more than one secret, all secrets are passed."
# 18a19,22
# >     },
# >     "nodeExpandSecretRef": {
# >       "$ref": "#/definitions/io.k8s.api.core.v1.SecretReference",
# >       "description": "nodeExpandSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodeExpandVolume call. This is an alpha field and requires enabling CSINodeExpandSecret feature gate. This field is optional, may be omitted if no secret is required. If the secret object contains more than one secret, all secrets are passed."
# diff -r 1.24orig/defs/io.k8s.api.core.v1.ContainerImage.json 1.25orig/defs/io.k8s.api.core.v1.ContainerImage.json
# 5c5
# <       "description": "Names by which this image is known. e.g. [\"k8s.gcr.io/hyperkube:v1.0.7\", \"dockerhub.io/google_containers/hyperkube:v1.0.7\"]",
# ---
# >       "description": "Names by which this image is known. e.g. [\"kubernetes.example/hyperkube:v1.0.7\", \"cloud-vendor.registry.example/cloud-vendor/hyperkube:v1.0.7\"]",
# diff -r 1.24orig/defs/io.k8s.api.core.v1.ServiceSpec.json 1.25orig/defs/io.k8s.api.core.v1.ServiceSpec.json
# 32c32
# <       "description": "externalTrafficPolicy denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints. \"Local\" preserves the client source IP and avoids a second hop for LoadBalancer and Nodeport type services, but risks potentially imbalanced traffic spreading. \"Cluster\" obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading.\n\n",
# ---
# >       "description": "externalTrafficPolicy describes how nodes distribute service traffic they receive on one of the Service's \"externally-facing\" addresses (NodePorts, ExternalIPs, and LoadBalancer IPs). If set to \"Local\", the proxy will configure the service in a way that assumes that external load balancers will take care of balancing the service traffic between nodes, and so each node will deliver traffic only to the node-local endpoints of the service, without masquerading the client source IP. (Traffic mistakenly sent to a node with no endpoints will be dropped.) The default value, \"Cluster\", uses the standard behavior of routing to all endpoints evenly (possibly modified by topology and other features). Note that traffic sent to an External IP or LoadBalancer IP from within the cluster will always get \"Cluster\" semantics, but clients sending to a NodePort from within the cluster may need to take traffic policy into account when picking a node.\n\n",
# 41c41
# <       "description": "InternalTrafficPolicy specifies if the cluster internal traffic should be routed to all endpoints or node-local endpoints only. \"Cluster\" routes internal traffic to a Service to all endpoints. \"Local\" routes traffic to node-local endpoints only, traffic is dropped if no node-local endpoints are ready. The default value is \"Cluster\".",
# ---
# >       "description": "InternalTrafficPolicy describes how nodes distribute service traffic they receive on the ClusterIP. If set to \"Local\", the proxy will assume that pods only want to talk to endpoints of the service on the same node as the pod, dropping the traffic if there are no local endpoints. The default value, \"Cluster\", uses the standard behavior of routing to all endpoints evenly (possibly modified by topology and other features).",
# diff -r 1.24orig/defs/io.k8s.api.core.v1.TopologySpreadConstraint.json 1.25orig/defs/io.k8s.api.core.v1.TopologySpreadConstraint.json
# 17a18,25
# >     "nodeAffinityPolicy": {
# >       "description": "NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector when calculating pod topology spread skew. Options are: - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations. - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.\n\nIf this value is nil, the behavior is equivalent to the Honor policy. This is a alpha-level feature enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.",
# >       "type": "string"
# >     },
# >     "nodeTaintsPolicy": {
# >       "description": "NodeTaintsPolicy indicates how we will treat node taints when calculating pod topology spread skew. Options are: - Honor: nodes without taints, along with tainted nodes for which the incoming pod has a toleration, are included. - Ignore: node taints are ignored. All nodes are included.\n\nIf this value is nil, the behavior is equivalent to the Ignore policy. This is a alpha-level feature enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.",
# >       "type": "string"
# >     },
# 19c27
# <       "description": "TopologyKey is the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology. We consider each <key, value> as a \"bucket\", and try to put balanced number of pods into each bucket. We define a domain as a particular instance of a topology. Also, we define an eligible domain as a domain whose nodes match the node selector. e.g. If TopologyKey is \"kubernetes.io/hostname\", each Node is a domain of that topology. And, if TopologyKey is \"topology.kubernetes.io/zone\", each zone is a domain of that topology. It's a required field.",
# ---
# >       "description": "TopologyKey is the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology. We consider each <key, value> as a \"bucket\", and try to put balanced number of pods into each bucket. We define a domain as a particular instance of a topology. Also, we define an eligible domain as a domain whose nodes meet the requirements of nodeAffinityPolicy and nodeTaintsPolicy. e.g. If TopologyKey is \"kubernetes.io/hostname\", each Node is a domain of that topology. And, if TopologyKey is \"topology.kubernetes.io/zone\", each zone is a domain of that topology. It's a required field.",
# diff -r 1.24orig/defs/io.k8s.api.networking.v1.IngressSpec.json 1.25orig/defs/io.k8s.api.networking.v1.IngressSpec.json
# 9c9
# <       "description": "IngressClassName is the name of the IngressClass cluster resource. The associated IngressClass defines which controller will implement the resource. This replaces the deprecated `kubernetes.io/ingress.class` annotation. For backwards compatibility, when that annotation is set, it must be given precedence over this field. The controller may emit a warning if the field and annotation have different values. Implementations of this API should ignore Ingresses without a class specified. An IngressClass resource may be marked as default, which can be used to set a default value for this field. For more information, refer to the IngressClass documentation.",
# ---
# >       "description": "IngressClassName is the name of an IngressClass cluster resource. Ingress controller implementations use this field to know whether they should be serving this Ingress resource, by a transitive connection (controller -> IngressClass -> Ingress resource). Although the `kubernetes.io/ingress.class` annotation (simple constant name) was never formally defined, it was widely supported by Ingress controllers to create a direct binding between Ingress controller and Ingress resources. Newly created Ingress resources should prefer using the field. However, even though the annotation is officially deprecated, for backwards compatibility reasons, ingress controllers should still honor that annotation if present.",

# diff -r 1.24orig/defs/io.k8s.api.rbac.v1.PolicyRule.json 1.25orig/defs/io.k8s.api.rbac.v1.PolicyRule.json
# 5c5
# <       "description": "APIGroups is the name of the APIGroup that contains the resources.  If multiple API groups are specified, any action requested against one of the enumerated resources in any API group will be allowed.",
# ---
# >       "description": "APIGroups is the name of the APIGroup that contains the resources.  If multiple API groups are specified, any action requested against one of the enumerated resources in any API group will be allowed. \"\" represents the core API group and \"*\" represents all API groups.",
# diff -r 1.24orig/defs/io.k8s.apimachinery.pkg.api.resource.Quantity.json 1.25orig/defs/io.k8s.apimachinery.pkg.api.resource.Quantity.json
# 2c2
# <   "description": "Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and AsInt64() accessors.\n\nThe serialization format is:\n\n<quantity>        ::= <signedNumber><suffix>\n  (Note that <suffix> may be empty, from the \"\" case in <decimalSI>.)\n<digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= \"+\" | \"-\" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei\n  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)\n<decimalSI>       ::= m | \"\" | k | M | G | T | P | E\n  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)\n<decimalExponent> ::= \"e\" <signedNumber> | \"E\" <signedNumber>\n\nNo matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.\n\nWhen a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.\n\nBefore serializing, Quantity will be put in \"canonical form\". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:\n  a. No precision is lost\n  b. No fractional digits will be emitted\n  c. The exponent (or suffix) is as large as possible.\nThe sign will be omitted unless the number is negative.\n\nExamples:\n  1.5 will be serialized as \"1500m\"\n  1.5Gi will be serialized as \"1536Mi\"\n\nNote that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.\n\nNon-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)\n\nThis format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.",
# ---
# >   "description": "Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and AsInt64() accessors.\n\nThe serialization format is:\n\n``` <quantity>        ::= <signedNumber><suffix>\n  (Note that <suffix> may be empty, from the \"\" case in <decimalSI>.)\n<digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= \"+\" | \"-\" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei\n  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)\n<decimalSI>       ::= m | \"\" | k | M | G | T | P | E\n  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)\n<decimalExponent> ::= \"e\" <signedNumber> | \"E\" <signedNumber> ```\n\nNo matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.\n\nWhen a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.\n\nBefore serializing, Quantity will be put in \"canonical form\". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:\n\n- No precision is lost - No fractional digits will be emitted - The exponent (or suffix) is as large as possible.\n\nThe sign will be omitted unless the number is negative.\n\nExamples:\n\n- 1.5 will be serialized as \"1500m\" - 1.5Gi will be serialized as \"1536Mi\"\n\nNote that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.\n\nNon-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)\n\nThis format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.",
# diff -r 1.24orig/defs/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta.json 1.25orig/defs/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta.json
# 11,14d10
# <     "clusterName": {
# <       "description": "Deprecated: ClusterName is a legacy field that was always cleared by the system and never used; it will be removed completely in 1.25.\n\nThe name in the go struct is changed to help clients detect accidental use.",
# <       "type": "string"
# <     },

## Operations

## Remove autoscaling/v2beta1
# Only in 1.24orig/ops: createAutoscalingV2beta1NamespacedHorizontalPodAutoscaler.json
# Only in 1.24orig/ops: deleteAutoscalingV2beta1CollectionNamespacedHorizontalPodAutoscaler.json
# Only in 1.24orig/ops: deleteAutoscalingV2beta1NamespacedHorizontalPodAutoscaler.json
# Only in 1.24orig/ops: getAutoscalingV2beta1APIResources.json
# Only in 1.24orig/ops: listAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces.json
# Only in 1.24orig/ops: listAutoscalingV2beta1NamespacedHorizontalPodAutoscaler.json
# Only in 1.24orig/ops: patchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler.json
# Only in 1.24orig/ops: patchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus.json
# Only in 1.24orig/ops: readAutoscalingV2beta1NamespacedHorizontalPodAutoscaler.json
# Only in 1.24orig/ops: readAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus.json
# Only in 1.24orig/ops: replaceAutoscalingV2beta1NamespacedHorizontalPodAutoscaler.json
# Only in 1.24orig/ops: replaceAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus.json

## Remove batch/v1beta1
# Only in 1.24orig/ops: createBatchV1beta1NamespacedCronJob.json
# Only in 1.24orig/ops: deleteBatchV1beta1CollectionNamespacedCronJob.json
# Only in 1.24orig/ops: deleteBatchV1beta1NamespacedCronJob.json
# Only in 1.24orig/ops: getBatchV1beta1APIResources.json
# Only in 1.24orig/ops: listBatchV1beta1CronJobForAllNamespaces.json
# Only in 1.24orig/ops: listBatchV1beta1NamespacedCronJob.json
# Only in 1.24orig/ops: patchBatchV1beta1NamespacedCronJob.json
# Only in 1.24orig/ops: patchBatchV1beta1NamespacedCronJobStatus.json
# Only in 1.24orig/ops: readBatchV1beta1NamespacedCronJob.json
# Only in 1.24orig/ops: readBatchV1beta1NamespacedCronJobStatus.json
# Only in 1.24orig/ops: replaceBatchV1beta1NamespacedCronJob.json
# Only in 1.24orig/ops: replaceBatchV1beta1NamespacedCronJobStatus.json

## Remove discovery/v1beta1
# Only in 1.24orig/ops: createDiscoveryV1beta1NamespacedEndpointSlice.json
# Only in 1.24orig/ops: deleteDiscoveryV1beta1CollectionNamespacedEndpointSlice.json
# Only in 1.24orig/ops: deleteDiscoveryV1beta1NamespacedEndpointSlice.json
# Only in 1.24orig/ops: getDiscoveryV1beta1APIResources.json
# Only in 1.24orig/ops: listDiscoveryV1beta1EndpointSliceForAllNamespaces.json
# Only in 1.24orig/ops: listDiscoveryV1beta1NamespacedEndpointSlice.json
# Only in 1.24orig/ops: patchDiscoveryV1beta1NamespacedEndpointSlice.json
# Only in 1.24orig/ops: readDiscoveryV1beta1NamespacedEndpointSlice.json
# Only in 1.24orig/ops: replaceDiscoveryV1beta1NamespacedEndpointSlice.json

## Remove events/v1beta1
# Only in 1.24orig/ops: createEventsV1beta1NamespacedEvent.json
# Only in 1.24orig/ops: deleteEventsV1beta1CollectionNamespacedEvent.json
# Only in 1.24orig/ops: deleteEventsV1beta1NamespacedEvent.json
# Only in 1.24orig/ops: getEventsV1beta1APIResources.json
# Only in 1.24orig/ops: listEventsV1beta1EventForAllNamespaces.json
# Only in 1.24orig/ops: listEventsV1beta1NamespacedEvent.json
# Only in 1.24orig/ops: patchEventsV1beta1NamespacedEvent.json
# Only in 1.24orig/ops: readEventsV1beta1NamespacedEvent.json
# Only in 1.24orig/ops: replaceEventsV1beta1NamespacedEvent.json

## Remove node/v1beta1
# Only in 1.24orig/ops: createNodeV1beta1RuntimeClass.json
# Only in 1.24orig/ops: deleteNodeV1beta1CollectionRuntimeClass.json
# Only in 1.24orig/ops: deleteNodeV1beta1RuntimeClass.json
# Only in 1.24orig/ops: getNodeV1beta1APIResources.json
# Only in 1.24orig/ops: listNodeV1beta1RuntimeClass.json
# Only in 1.24orig/ops: patchNodeV1beta1RuntimeClass.json
# Only in 1.24orig/ops: readNodeV1beta1RuntimeClass.json
# Only in 1.24orig/ops: replaceNodeV1beta1RuntimeClass.json

## Remove policy/v1beta1
# Only in 1.24orig/ops: createPolicyV1beta1NamespacedPodDisruptionBudget.json
# Only in 1.24orig/ops: deletePolicyV1beta1CollectionNamespacedPodDisruptionBudget.json
# Only in 1.24orig/ops: deletePolicyV1beta1NamespacedPodDisruptionBudget.json
# Only in 1.24orig/ops: getPolicyV1beta1APIResources.json
# Only in 1.24orig/ops: listPolicyV1beta1NamespacedPodDisruptionBudget.json
# Only in 1.24orig/ops: listPolicyV1beta1PodDisruptionBudgetForAllNamespaces.json
# Only in 1.24orig/ops: patchPolicyV1beta1NamespacedPodDisruptionBudget.json
# Only in 1.24orig/ops: patchPolicyV1beta1NamespacedPodDisruptionBudgetStatus.json
# Only in 1.24orig/ops: readPolicyV1beta1NamespacedPodDisruptionBudget.json
# Only in 1.24orig/ops: readPolicyV1beta1NamespacedPodDisruptionBudgetStatus.json
# Only in 1.24orig/ops: replacePolicyV1beta1NamespacedPodDisruptionBudget.json
# Only in 1.24orig/ops: replacePolicyV1beta1NamespacedPodDisruptionBudgetStatus.json

# Only in 1.24orig/ops: createPolicyV1beta1PodSecurityPolicy.json
# Only in 1.24orig/ops: deletePolicyV1beta1CollectionPodSecurityPolicy.json
# Only in 1.24orig/ops: deletePolicyV1beta1PodSecurityPolicy.json
# Only in 1.24orig/ops: listPolicyV1beta1PodSecurityPolicy.json
# Only in 1.24orig/ops: patchPolicyV1beta1PodSecurityPolicy.json
# Only in 1.24orig/ops: readPolicyV1beta1PodSecurityPolicy.json
# Only in 1.24orig/ops: replacePolicyV1beta1PodSecurityPolicy.json

