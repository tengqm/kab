# Only in 1.34orig/defs: io.k8s.api.admissionregistration.v1beta1.ApplyConfiguration.json
# Only in 1.33orig/defs: io.k8s.api.admissionregistration.v1beta1.AuditAnnotation.json
# Only in 1.33orig/defs: io.k8s.api.admissionregistration.v1beta1.ExpressionWarning.json
# Only in 1.34orig/defs: io.k8s.api.admissionregistration.v1beta1.JSONPatch.json
# Only in 1.34orig/defs: io.k8s.api.admissionregistration.v1beta1.MutatingAdmissionPolicy.json
# Only in 1.34orig/defs: io.k8s.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBinding.json
# Only in 1.34orig/defs: io.k8s.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBindingList.json
# Only in 1.34orig/defs: io.k8s.api.admissionregistration.v1beta1.MutatingAdmissionPolicyBindingSpec.json
# Only in 1.34orig/defs: io.k8s.api.admissionregistration.v1beta1.MutatingAdmissionPolicyList.json
# Only in 1.34orig/defs: io.k8s.api.admissionregistration.v1beta1.MutatingAdmissionPolicySpec.json
# Only in 1.34orig/defs: io.k8s.api.admissionregistration.v1beta1.Mutation.json

# Only in 1.33orig/defs: io.k8s.api.admissionregistration.v1beta1.TypeChecking.json
# Only in 1.33orig/defs: io.k8s.api.admissionregistration.v1beta1.ValidatingAdmissionPolicy.json
# Only in 1.33orig/defs: io.k8s.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBinding.json
# Only in 1.33orig/defs: io.k8s.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingList.json
# Only in 1.33orig/defs: io.k8s.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyBindingSpec.json
# Only in 1.33orig/defs: io.k8s.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyList.json
# Only in 1.33orig/defs: io.k8s.api.admissionregistration.v1beta1.ValidatingAdmissionPolicySpec.json
# Only in 1.33orig/defs: io.k8s.api.admissionregistration.v1beta1.ValidatingAdmissionPolicyStatus.json
# Only in 1.33orig/defs: io.k8s.api.admissionregistration.v1beta1.Validation.json

# diff 1.33orig/defs/io.k8s.api.apps.v1.RollingUpdateDaemonSet.json 1.34orig/defs/io.k8s.api.apps.v1.RollingUpdateDaemonSet.json
# 6c6
# <       "description": "The maximum number of nodes with an existing available DaemonSet pod that can have an updated DaemonSet pod during during an update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up to a minimum of 1. Default value is 0. Example: when this is set to 30%, at most 30% of the total number of nodes that should be running the daemon pod (i.e. status.desiredNumberScheduled) can have their a new pod created before the old pod is marked as deleted. The update starts by launching new pods on 30% of nodes. Once an updated pod is available (Ready for at least minReadySeconds) the old DaemonSet pod on that node is marked deleted. If the old pod becomes unavailable for any reason (Ready transitions to false, is evicted, or is drained) an updated pod is immediatedly created on that node without considering surge limits. Allowing surge implies the possibility that the resources consumed by the daemonset on any given node can double if the readiness check fails, and so resource intensive daemonsets should take into account that they may cause evictions during disruption."
# ---
# >       "description": "The maximum number of nodes with an existing available DaemonSet pod that can have an updated DaemonSet pod during during an update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up to a minimum of 1. Default value is 0. Example: when this is set to 30%, at most 30% of the total number of nodes that should be running the daemon pod (i.e. status.desiredNumberScheduled) can have their a new pod created before the old pod is marked as deleted. The update starts by launching new pods on 30% of nodes. Once an updated pod is available (Ready for at least minReadySeconds) the old DaemonSet pod on that node is marked deleted. If the old pod becomes unavailable for any reason (Ready transitions to false, is evicted, or is drained) an updated pod is immediately created on that node without considering surge limits. Allowing surge implies the possibility that the resources consumed by the daemonset on any given node can double if the readiness check fails, and so resource intensive daemonsets should take into account that they may cause evictions during disruption."
# diff 1.33orig/defs/io.k8s.api.authorization.v1.ResourceAttributes.json 1.34orig/defs/io.k8s.api.authorization.v1.ResourceAttributes.json
# 6c6
# <       "description": "fieldSelector describes the limitation on access based on field.  It can only limit access, not broaden it.\n\nThis field  is alpha-level. To use this field, you must enable the `AuthorizeWithSelectors` feature gate (disabled by default)."
# ---
# >       "description": "fieldSelector describes the limitation on access based on field.  It can only limit access, not broaden it."
# 14c14
# <       "description": "labelSelector describes the limitation on access based on labels.  It can only limit access, not broaden it.\n\nThis field  is alpha-level. To use this field, you must enable the `AuthorizeWithSelectors` feature gate (disabled by default)."
# ---
# >       "description": "labelSelector describes the limitation on access based on labels.  It can only limit access, not broaden it."
# diff 1.33orig/defs/io.k8s.api.batch.v1.JobSpec.json 1.34orig/defs/io.k8s.api.batch.v1.JobSpec.json
# 10c10
# <       "description": "Specifies the number of retries before marking this job failed. Defaults to 6",
# ---
# >       "description": "Specifies the number of retries before marking this job failed. Defaults to 6, unless backoffLimitPerIndex (only Indexed Job) is specified. When backoffLimitPerIndex is specified, backoffLimit defaults to 2147483647.",
# 51c51
# <       "description": "podReplacementPolicy specifies when to create replacement Pods. Possible values are: - TerminatingOrFailed means that we recreate pods\n  when they are terminating (has a metadata.deletionTimestamp) or failed.\n- Failed means to wait until a previously created Pod is fully terminated (has phase\n  Failed or Succeeded) before creating a replacement Pod.\n\nWhen using podFailurePolicy, Failed is the the only allowed value. TerminatingOrFailed and Failed are allowed values when podFailurePolicy is not in use. This is an beta field. To use this, enable the JobPodReplacementPolicy feature toggle. This is on by default.",
# ---
# >       "description": "podReplacementPolicy specifies when to create replacement Pods. Possible values are: - TerminatingOrFailed means that we recreate pods\n  when they are terminating (has a metadata.deletionTimestamp) or failed.\n- Failed means to wait until a previously created Pod is fully terminated (has phase\n  Failed or Succeeded) before creating a replacement Pod.\n\nWhen using podFailurePolicy, Failed is the the only allowed value. TerminatingOrFailed and Failed are allowed values when podFailurePolicy is not in use.",
# diff 1.33orig/defs/io.k8s.api.batch.v1.SuccessPolicy.json 1.34orig/defs/io.k8s.api.batch.v1.SuccessPolicy.json
# 5c5
# <       "description": "rules represents the list of alternative rules for the declaring the Jobs as successful before `.status.succeeded >= .spec.completions`. Once any of the rules are met, the \"SucceededCriteriaMet\" condition is added, and the lingering pods are removed. The terminal state for such a Job has the \"Complete\" condition. Additionally, these rules are evaluated in order; Once the Job meets one of the rules, other rules are ignored. At most 20 elements are allowed.",
# ---
# >       "description": "rules represents the list of alternative rules for the declaring the Jobs as successful before `.status.succeeded >= .spec.completions`. Once any of the rules are met, the \"SuccessCriteriaMet\" condition is added, and the lingering pods are removed. The terminal state for such a Job has the \"Complete\" condition. Additionally, these rules are evaluated in order; Once the Job meets one of the rules, other rules are ignored. At most 20 elements are allowed.",
# Only in 1.34orig/defs: io.k8s.api.certificates.v1alpha1.PodCertificateRequest.json
# Only in 1.34orig/defs: io.k8s.api.certificates.v1alpha1.PodCertificateRequestList.json
# Only in 1.34orig/defs: io.k8s.api.certificates.v1alpha1.PodCertificateRequestSpec.json
# Only in 1.34orig/defs: io.k8s.api.certificates.v1alpha1.PodCertificateRequestStatus.json

# diff 1.33orig/defs/io.k8s.api.core.v1.Container.json 1.34orig/defs/io.k8s.api.core.v1.Container.json
# 34c34
# <       "description": "List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.",
# ---
# >       "description": "List of sources to populate environment variables in the container. The keys defined within a source may consist of any printable ASCII characters except '='. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.",
# 92c92
# <       "description": "RestartPolicy defines the restart behavior of individual containers in a pod. This field may only be set for init containers, and the only allowed value is \"Always\". For non-init containers or when this field is not specified, the restart behavior is defined by the Pod's restart policy and the container type. Setting the RestartPolicy as \"Always\" for the init container will have the following effect: this init container will be continually restarted on exit until all regular containers have terminated. Once all regular containers have completed, all init containers with restartPolicy \"Always\" will be shut down. This lifecycle differs from normal init containers and is often referred to as a \"sidecar\" container. Although this init container still starts in the init container sequence, it does not wait for the container to complete before proceeding to the next init container. Instead, the next init container starts immediately after this init container is started, or after any startupProbe has successfully completed.",
# ---
# >       "description": "RestartPolicy defines the restart behavior of individual containers in a pod. This overrides the pod-level restart policy. When this field is not specified, the restart behavior is defined by the Pod's restart policy and the container type. Additionally, setting the RestartPolicy as \"Always\" for the init container will have the following effect: this init container will be continually restarted on exit until all regular containers have terminated. Once all regular containers have completed, all init containers with restartPolicy \"Always\" will be shut down. This lifecycle differs from normal init containers and is often referred to as a \"sidecar\" container. Although this init container still starts in the init container sequence, it does not wait for the container to complete before proceeding to the next init container. Instead, the next init container starts immediately after this init container is started, or after any startupProbe has successfully completed.",
# 93a94,101
# >     },
# >     "restartPolicyRules": {
# >       "description": "Represents a list of rules to be checked to determine if the container should be restarted on exit. The rules are evaluated in order. Once a rule matches a container exit condition, the remaining rules are ignored. If no rule matches the container exit condition, the Container-level restart policy determines the whether the container is restarted or not. Constraints on the rules: - At most 20 rules are allowed. - Rules can have the same action. - Identical rules are not forbidden in validations. When rules are specified, container MUST set RestartPolicy explicitly even it if matches the Pod's RestartPolicy.",
# >       "items": {
# >         "$ref": "#/definitions/io.k8s.api.core.v1.ContainerRestartRule"
# >       },
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# Only in 1.34orig/defs: io.k8s.api.core.v1.ContainerExtendedResourceRequest.json
# Only in 1.34orig/defs: io.k8s.api.core.v1.ContainerRestartRule.json
# Only in 1.34orig/defs: io.k8s.api.core.v1.ContainerRestartRuleOnExitCodes.json
# diff 1.33orig/defs/io.k8s.api.core.v1.EnvFromSource.json 1.34orig/defs/io.k8s.api.core.v1.EnvFromSource.json
# 9c9
# <       "description": "Optional text to prepend to the name of each environment variable. Must be a C_IDENTIFIER.",
# ---
# >       "description": "Optional text to prepend to the name of each environment variable. May consist of any printable ASCII characters except '='.",
# diff 1.33orig/defs/io.k8s.api.core.v1.EnvVar.json 1.34orig/defs/io.k8s.api.core.v1.EnvVar.json
# 5c5
# <       "description": "Name of the environment variable. Must be a C_IDENTIFIER.",
# ---
# >       "description": "Name of the environment variable. May consist of any printable ASCII characters except '='.",
# diff 1.33orig/defs/io.k8s.api.core.v1.EnvVarSource.json 1.34orig/defs/io.k8s.api.core.v1.EnvVarSource.json
# 11a12,15
# >     "fileKeyRef": {
# >       "$ref": "#/definitions/io.k8s.api.core.v1.FileKeySelector",
# >       "description": "FileKeyRef selects a key of the env file. Requires the EnvFiles feature gate to be enabled."
# >     },
# diff 1.33orig/defs/io.k8s.api.core.v1.EphemeralContainer.json 1.34orig/defs/io.k8s.api.core.v1.EphemeralContainer.json
# 34c34
# <       "description": "List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.",
# ---
# >       "description": "List of sources to populate environment variables in the container. The keys defined within a source may consist of any printable ASCII characters except '='. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.",
# 92c92
# <       "description": "Restart policy for the container to manage the restart behavior of each container within a pod. This may only be set for init containers. You cannot set this field on ephemeral containers.",
# ---
# >       "description": "Restart policy for the container to manage the restart behavior of each container within a pod. You cannot set this field on ephemeral containers.",
93a94,101
# >     },
# >     "restartPolicyRules": {
# >       "description": "Represents a list of rules to be checked to determine if the container should be restarted on exit. You cannot set this field on ephemeral containers.",
# >       "items": {
# >         "$ref": "#/definitions/io.k8s.api.core.v1.ContainerRestartRule"
# >       },
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# Only in 1.34orig/defs: io.k8s.api.core.v1.FileKeySelector.json
# diff 1.33orig/defs/io.k8s.api.core.v1.GlusterfsVolumeSource.json 1.34orig/defs/io.k8s.api.core.v1.GlusterfsVolumeSource.json
# 5c5
# <       "description": "endpoints is the endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod",
# ---
# >       "description": "endpoints is the endpoint name that details Glusterfs topology.",
# diff 1.33orig/defs/io.k8s.api.core.v1.PersistentVolumeClaimSpec.json 1.34orig/defs/io.k8s.api.core.v1.PersistentVolumeClaimSpec.json
# 33c33
# <       "description": "volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim. If specified, the CSI driver will create or update the volume with the attributes defined in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName, it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass will be applied to the claim but it's not allowed to reset this field to empty string once it is set. If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass will be set by the persistentvolume controller if it exists. If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource exists. More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/ (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).",
# ---
# >       "description": "volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim. If specified, the CSI driver will create or update the volume with the attributes defined in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName, it can be changed after the claim is created. An empty string or nil value indicates that no VolumeAttributesClass will be applied to the claim. If the claim enters an Infeasible error state, this field can be reset to its previous value (including nil) to cancel the modification. If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource exists. More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/",
# diff 1.33orig/defs/io.k8s.api.core.v1.PersistentVolumeClaimStatus.json 1.34orig/defs/io.k8s.api.core.v1.PersistentVolumeClaimStatus.json
# 48c48
# <       "description": "currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using. When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim This is a beta field and requires enabling VolumeAttributesClass feature (off by default).",
# ---
# >       "description": "currentVolumeAttributesClassName is the current name of the VolumeAttributesClass the PVC is using. When unset, there is no VolumeAttributeClass applied to this PersistentVolumeClaim",
# 53c53
# <       "description": "ModifyVolumeStatus represents the status object of ControllerModifyVolume operation. When this is unset, there is no ModifyVolume operation being attempted. This is a beta field and requires enabling VolumeAttributesClass feature (off by default)."
# ---
# >       "description": "ModifyVolumeStatus represents the status object of ControllerModifyVolume operation. When this is unset, there is no ModifyVolume operation being attempted."
# diff 1.33orig/defs/io.k8s.api.core.v1.PersistentVolumeSpec.json 1.34orig/defs/io.k8s.api.core.v1.PersistentVolumeSpec.json
# 129c129
# <       "description": "Name of VolumeAttributesClass to which this persistent volume belongs. Empty value is not allowed. When this field is not set, it indicates that this volume does not belong to any VolumeAttributesClass. This field is mutable and can be changed by the CSI driver after a volume has been updated successfully to a new class. For an unbound PersistentVolume, the volumeAttributesClassName will be matched with unbound PersistentVolumeClaims during the binding process. This is a beta field and requires enabling VolumeAttributesClass feature (off by default).",
# ---
# >       "description": "Name of VolumeAttributesClass to which this persistent volume belongs. Empty value is not allowed. When this field is not set, it indicates that this volume does not belong to any VolumeAttributesClass. This field is mutable and can be changed by the CSI driver after a volume has been updated successfully to a new class. For an unbound PersistentVolume, the volumeAttributesClassName will be matched with unbound PersistentVolumeClaims during the binding process.",
# diff 1.33orig/defs/io.k8s.api.core.v1.PodAntiAffinity.json 1.34orig/defs/io.k8s.api.core.v1.PodAntiAffinity.json
# 5c5
# <       "description": "The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \"weight\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.",
# ---
# >       "description": "The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and subtracting \"weight\" from the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.",
# Only in 1.34orig/defs: io.k8s.api.core.v1.PodCertificateProjection.json
# Only in 1.34orig/defs: io.k8s.api.core.v1.PodExtendedResourceClaimStatus.json
# diff 1.33orig/defs/io.k8s.api.core.v1.PodSpec.json 1.34orig/defs/io.k8s.api.core.v1.PodSpec.json
# 73c73
# <       "description": "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
# ---
# >       "description": "Host networking requested for this pod. Use the host's network namespace. When using HostNetwork you should specify ports so the scheduler is aware. When `hostNetwork` is true, specified `hostPort` fields in port definitions must match `containerPort`, and unspecified `hostPort` fields in port definitions are defaulted to match `containerPort`. Default to false.",
# 87a88,91
# >     "hostnameOverride": {
# >       "description": "HostnameOverride specifies an explicit override for the pod's hostname as perceived by the pod. This field only specifies the pod's hostname and does not affect its DNS records. When this field is set to a non-empty string: - It takes precedence over the values set in `hostname` and `subdomain`. - The Pod's hostname will be set to this value. - `setHostnameAsFQDN` must be nil or set to false. - `hostNetwork` must be set to false.\n\nThis field must be a valid DNS subdomain as defined in RFC 1123 and contain at most 64 characters. Requires the HostnameOverride feature gate to be enabled.",
# >       "type": "string"
# >     },
# 128c132
# <       "description": "Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set.\n\nIf the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions\n\nIf the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.securityContext.appArmorProfile - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.securityContext.supplementalGroupsPolicy - spec.containers[*].securityContext.appArmorProfile - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup"
# ---
# >       "description": "Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set.\n\nIf the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions\n\nIf the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.resources - spec.securityContext.appArmorProfile - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.securityContext.supplementalGroupsPolicy - spec.containers[*].securityContext.appArmorProfile - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup"
# 173c177
# <       "description": "Resources is the total amount of CPU and Memory resources required by all containers in the pod. It supports specifying Requests and Limits for \"cpu\" and \"memory\" resource names only. ResourceClaims are not supported.\n\nThis field enables fine-grained control over resource allocation for the entire pod, allowing resource sharing among containers in a pod.\n\nThis is an alpha field and requires enabling the PodLevelResources feature gate."
# ---
# >       "description": "Resources is the total amount of CPU and Memory resources required by all containers in the pod. It supports specifying Requests and Limits for \"cpu\", \"memory\" and \"hugepages-\" resource names only. ResourceClaims are not supported.\n\nThis field enables fine-grained control over resource allocation for the entire pod, allowing resource sharing among containers in a pod.\n\nThis is an alpha field and requires enabling the PodLevelResources feature gate."
# diff 1.33orig/defs/io.k8s.api.core.v1.PodStatus.json 1.34orig/defs/io.k8s.api.core.v1.PodStatus.json
# 32a33,36
# >     "extendedResourceClaimStatus": {
# >       "$ref": "#/definitions/io.k8s.api.core.v1.PodExtendedResourceClaimStatus",
# >       "description": "Status of extended resource claim backed by DRA."
# >     },
# diff 1.33orig/defs/io.k8s.api.core.v1.ResourceRequirements.json 1.34orig/defs/io.k8s.api.core.v1.ResourceRequirements.json
# 5c5
# <       "description": "Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.\n\nThis is an alpha field and requires enabling the DynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.",
# ---
# >       "description": "Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.\n\nThis field depends on the DynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.",
# diff 1.33orig/defs/io.k8s.api.core.v1.Taint.json 1.34orig/defs/io.k8s.api.core.v1.Taint.json
# 14c14
# <       "description": "TimeAdded represents the time at which the taint was added. It is only written for NoExecute taints."
# ---
# >       "description": "TimeAdded represents the time at which the taint was added."
# diff 1.33orig/defs/io.k8s.api.core.v1.Volume.json 1.34orig/defs/io.k8s.api.core.v1.Volume.json
# 66c66
# <       "description": "glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported. More info: https://examples.k8s.io/volumes/glusterfs/README.md"
# ---
# >       "description": "glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported."
# 78c78
# <       "description": "iscsi represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md"
# ---
# >       "description": "iscsi represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes/#iscsi"
# 110c110
# <       "description": "rbd represents a Rados Block Device mount on the host that shares a pod's lifetime. Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported. More info: https://examples.k8s.io/volumes/rbd/README.md"
# ---
# >       "description": "rbd represents a Rados Block Device mount on the host that shares a pod's lifetime. Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported."
# diff 1.33orig/defs/io.k8s.api.core.v1.VolumeProjection.json 1.34orig/defs/io.k8s.api.core.v1.VolumeProjection.json
# 15a16,19
# >     "podCertificate": {
# >       "$ref": "#/definitions/io.k8s.api.core.v1.PodCertificateProjection",
# >       "description": "Projects an auto-rotating credential bundle (private key and certificate chain) that the pod can use either as a TLS client or server.\n\nKubelet generates a private key and uses it to send a PodCertificateRequest to the named signer.  Once the signer approves the request and issues a certificate chain, Kubelet writes the key and certificate chain to the pod filesystem.  The pod does not start until certificates have been issued for each podCertificate projected volume source in its spec.\n\nKubelet will begin trying to rotate the certificate at the time indicated by the signer using the PodCertificateRequest.Status.BeginRefreshAt timestamp.\n\nKubelet can write a single file, indicated by the credentialBundlePath field, or separate files, indicated by the keyPath and certificateChainPath fields.\n\nThe credential bundle is a single file in PEM format.  The first PEM entry is the private key (in PKCS#8 format), and the remaining PEM entries are the certificate chain issued by the signer (typically, signers will return their certificate chain in leaf-to-root order).\n\nPrefer using the credential bundle format, since your application code can read it atomically.  If you use keyPath and certificateChainPath, your application must make two separate file reads. If these coincide with a certificate rotation, it is possible that the private key and leaf certificate you read may not correspond to each other.  Your application will need to check for this condition, and re-read until they are consistent.\n\nThe named signer controls chooses the format of the certificate it issues; consult the signer implementation's documentation to learn how to use the certificates it issues."
# >     },
# diff 1.33orig/defs/io.k8s.api.networking.v1.NetworkPolicySpec.json 1.34orig/defs/io.k8s.api.networking.v1.NetworkPolicySpec.json
# 22c22
# <       "description": "podSelector selects the pods to which this NetworkPolicy object applies. The array of ingress rules is applied to any pods selected by this field. Multiple network policies can select the same set of pods. In this case, the ingress rules for each are combined additively. This field is NOT optional and follows standard label selector semantics. An empty podSelector matches all pods in this namespace."
# ---
# >       "description": "podSelector selects the pods to which this NetworkPolicy object applies. The array of rules is applied to any pods selected by this field. An empty selector matches all pods in the policy's namespace. Multiple network policies can select the same set of pods. In this case, the ingress rules for each are combined additively. This field is optional. If it is not specified, it defaults to an empty selector."
# 33,35d32
# <   "required": [
# <     "podSelector"
# <   ],

# Only in 1.34orig/defs: io.k8s.api.resource.v1.AllocatedDeviceStatus.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.AllocationResult.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.CELDeviceSelector.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.CapacityRequestPolicy.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.CapacityRequestPolicyRange.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.CapacityRequirements.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.Counter.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.CounterSet.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.Device.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.DeviceAllocationConfiguration.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.OpaqueDeviceConfiguration.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.DeviceAllocationResult.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.DeviceAttribute.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.DeviceCapacity.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.DeviceClaim.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.DeviceClaimConfiguration.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.DeviceClass.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.DeviceClassConfiguration.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.DeviceClassList.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.DeviceClassSpec.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.DeviceConstraint.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.DeviceCounterConsumption.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.DeviceRequest.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.DeviceRequestAllocationResult.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.DeviceSelector.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.DeviceSubRequest.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.DeviceTaint.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.DeviceToleration.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.ExactDeviceRequest.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.NetworkDeviceData.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.ResourceClaim.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.ResourceClaimConsumerReference.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.ResourceClaimList.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.ResourceClaimSpec.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.ResourceClaimStatus.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.ResourceClaimTemplate.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.ResourceClaimTemplateList.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.ResourceClaimTemplateSpec.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.ResourcePool.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.ResourceSlice.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.ResourceSliceList.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1.ResourceSliceSpec.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.AllocatedDeviceStatus.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.AllocationResult.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.BasicDevice.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.Counter.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.CounterSet.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.Device.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.DeviceAllocationConfiguration.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.DeviceAllocationResult.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.DeviceAttribute.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.DeviceClaim.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.DeviceClaimConfiguration.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.DeviceClass.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.DeviceClassConfiguration.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.DeviceClassList.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.DeviceClassSpec.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.DeviceConstraint.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.DeviceCounterConsumption.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.DeviceRequest.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.DeviceRequestAllocationResult.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.DeviceSubRequest.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.DeviceToleration.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.NetworkDeviceData.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.OpaqueDeviceConfiguration.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.ResourceClaim.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.ResourceClaimConsumerReference.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.ResourceClaimList.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.ResourceClaimSpec.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.ResourceClaimStatus.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.ResourceClaimTemplate.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.ResourceClaimTemplateList.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.ResourceClaimTemplateSpec.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.ResourcePool.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.ResourceSlice.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.ResourceSliceList.json
# Only in 1.33orig/defs: io.k8s.api.resource.v1alpha3.ResourceSliceSpec.json
# diff 1.33orig/defs/io.k8s.api.resource.v1beta1.AllocatedDeviceStatus.json 1.34orig/defs/io.k8s.api.resource.v1beta1.AllocatedDeviceStatus.json
# 2c2
# <   "description": "AllocatedDeviceStatus contains the status of an allocated device, if the driver chooses to report it. This may include driver-specific information.",
# ---
# >   "description": "AllocatedDeviceStatus contains the status of an allocated device, if the driver chooses to report it. This may include driver-specific information.\n\nThe combination of Driver, Pool, Device, and ShareID must match the corresponding key in Status.Allocation.Devices.",
# 32a33,36
# >       "type": "string"
# >     },
# >     "shareID": {
# >       "description": "ShareID uniquely identifies an individual allocation share of the device.",
# diff 1.33orig/defs/io.k8s.api.resource.v1beta1.AllocationResult.json 1.34orig/defs/io.k8s.api.resource.v1beta1.AllocationResult.json
# 3a4,7
# >     "allocationTimestamp": {
# >       "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time",
# >       "description": "AllocationTimestamp stores the time when the resources were allocated. This field is not guaranteed to be set, in which case that time is unknown.\n\nThis is an alpha field and requires enabling the DRADeviceBindingConditions and DRAResourceClaimDeviceStatus feature gate."
# >     },
# diff 1.33orig/defs/io.k8s.api.resource.v1beta1.BasicDevice.json 1.34orig/defs/io.k8s.api.resource.v1beta1.BasicDevice.json
# 7a8,11
# >     "allowMultipleAllocations": {
# >       "description": "AllowMultipleAllocations marks whether the device is allowed to be allocated to multiple DeviceRequests.\n\nIf AllowMultipleAllocations is set to true, the device can be allocated more than once, and all of its capacity is consumable, regardless of whether the requestPolicy is defined or not.",
# >       "type": "boolean"
# >     },
# 13a18,37
# >     },
# >     "bindingConditions": {
# >       "description": "BindingConditions defines the conditions for proceeding with binding. All of these conditions must be set in the per-device status conditions with a value of True to proceed with binding the pod to the node while scheduling the pod.\n\nThe maximum number of binding conditions is 4.\n\nThe conditions must be a valid condition type string.\n\nThis is an alpha field and requires enabling the DRADeviceBindingConditions and DRAResourceClaimDeviceStatus feature gates.",
# >       "items": {
# >         "type": "string"
# >       },
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# >     },
# >     "bindingFailureConditions": {
# >       "description": "BindingFailureConditions defines the conditions for binding failure. They may be set in the per-device status conditions. If any is true, a binding failure occurred.\n\nThe maximum number of binding failure conditions is 4.\n\nThe conditions must be a valid condition type string.\n\nThis is an alpha field and requires enabling the DRADeviceBindingConditions and DRAResourceClaimDeviceStatus feature gates.",
# >       "items": {
# >         "type": "string"
# >       },
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# >     },
# >     "bindsToNode": {
# >       "description": "BindsToNode indicates if the usage of an allocation involving this device has to be limited to exactly the node that was chosen when allocating the claim. If set to true, the scheduler will set the ResourceClaim.Status.Allocation.NodeSelector to match the node where the allocation was made.\n\nThis is an alpha field and requires enabling the DRADeviceBindingConditions and DRAResourceClaimDeviceStatus feature gates.",
# >       "type": "boolean"
# diff 1.33orig/defs/io.k8s.api.resource.v1beta1.CELDeviceSelector.json 1.34orig/defs/io.k8s.api.resource.v1beta1.CELDeviceSelector.json
# 5c5
# <       "description": "Expression is a CEL expression which evaluates a single device. It must evaluate to true when the device under consideration satisfies the desired criteria, and false when it does not. Any other result is an error and causes allocation of devices to abort.\n\nThe expression's input is an object named \"device\", which carries the following properties:\n - driver (string): the name of the driver which defines this device.\n - attributes (map[string]object): the device's attributes, grouped by prefix\n   (e.g. device.attributes[\"dra.example.com\"] evaluates to an object with all\n   of the attributes which were prefixed by \"dra.example.com\".\n - capacity (map[string]object): the device's capacities, grouped by prefix.\n\nExample: Consider a device with driver=\"dra.example.com\", which exposes two attributes named \"model\" and \"ext.example.com/family\" and which exposes one capacity named \"modules\". This input to this expression would have the following fields:\n\n    device.driver\n    device.attributes[\"dra.example.com\"].model\n    device.attributes[\"ext.example.com\"].family\n    device.capacity[\"dra.example.com\"].modules\n\nThe device.driver field can be used to check for a specific driver, either as a high-level precondition (i.e. you only want to consider devices from this driver) or as part of a multi-clause expression that is meant to consider devices from different drivers.\n\nThe value type of each attribute is defined by the device definition, and users who write these expressions must consult the documentation for their specific drivers. The value type of each capacity is Quantity.\n\nIf an unknown prefix is used as a lookup in either device.attributes or device.capacity, an empty map will be returned. Any reference to an unknown field will cause an evaluation error and allocation to abort.\n\nA robust expression should check for the existence of attributes before referencing them.\n\nFor ease of use, the cel.bind() function is enabled, and can be used to simplify expressions that access multiple attributes with the same domain. For example:\n\n    cel.bind(dra, device.attributes[\"dra.example.com\"], dra.someBool && dra.anotherBool)\n\nThe length of the expression must be smaller or equal to 10 Ki. The cost of evaluating it is also limited based on the estimated number of logical steps.",
# ---
# >       "description": "Expression is a CEL expression which evaluates a single device. It must evaluate to true when the device under consideration satisfies the desired criteria, and false when it does not. Any other result is an error and causes allocation of devices to abort.\n\nThe expression's input is an object named \"device\", which carries the following properties:\n - driver (string): the name of the driver which defines this device.\n - attributes (map[string]object): the device's attributes, grouped by prefix\n   (e.g. device.attributes[\"dra.example.com\"] evaluates to an object with all\n   of the attributes which were prefixed by \"dra.example.com\".\n - capacity (map[string]object): the device's capacities, grouped by prefix.\n - allowMultipleAllocations (bool): the allowMultipleAllocations property of the device\n   (v1.34+ with the DRAConsumableCapacity feature enabled).\n\nExample: Consider a device with driver=\"dra.example.com\", which exposes two attributes named \"model\" and \"ext.example.com/family\" and which exposes one capacity named \"modules\". This input to this expression would have the following fields:\n\n    device.driver\n    device.attributes[\"dra.example.com\"].model\n    device.attributes[\"ext.example.com\"].family\n    device.capacity[\"dra.example.com\"].modules\n\nThe device.driver field can be used to check for a specific driver, either as a high-level precondition (i.e. you only want to consider devices from this driver) or as part of a multi-clause expression that is meant to consider devices from different drivers.\n\nThe value type of each attribute is defined by the device definition, and users who write these expressions must consult the documentation for their specific drivers. The value type of each capacity is Quantity.\n\nIf an unknown prefix is used as a lookup in either device.attributes or device.capacity, an empty map will be returned. Any reference to an unknown field will cause an evaluation error and allocation to abort.\n\nA robust expression should check for the existence of attributes before referencing them.\n\nFor ease of use, the cel.bind() function is enabled, and can be used to simplify expressions that access multiple attributes with the same domain. For example:\n\n    cel.bind(dra, device.attributes[\"dra.example.com\"], dra.someBool && dra.anotherBool)\n\nThe length of the expression must be smaller or equal to 10 Ki. The cost of evaluating it is also limited based on the estimated number of logical steps.",
# Only in 1.34orig/defs: io.k8s.api.resource.v1beta1.CapacityRequestPolicy.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1beta1.CapacityRequestPolicyRange.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1beta1.CapacityRequirements.json
# diff 1.33orig/defs/io.k8s.api.resource.v1beta1.DeviceCapacity.json 1.34orig/defs/io.k8s.api.resource.v1beta1.DeviceCapacity.json
# 3a4,7
# >     "requestPolicy": {
# >       "$ref": "#/definitions/io.k8s.api.resource.v1beta1.CapacityRequestPolicy",
# >       "description": "RequestPolicy defines how this DeviceCapacity must be consumed when the device is allowed to be shared by multiple allocations.\n\nThe Device must have allowMultipleAllocations set to true in order to set a requestPolicy.\n\nIf unset, capacity requests are unconstrained: requests can consume any amount of capacity, as long as the total consumed across all allocations does not exceed the device's defined capacity. If request is also unset, default is the full capacity value."
# >     },
# 6c10
# <       "description": "Value defines how much of a certain device capacity is available."
# ---
# >       "description": "Value defines how much of a certain capacity that device has.\n\nThis field reflects the fixed total capacity and does not change. The consumed amount is tracked separately by scheduler and does not affect this value."
# # diff 1.33orig/defs/io.k8s.api.resource.v1beta1.DeviceClassSpec.json 1.34orig/defs/io.k8s.api.resource.v1beta1.DeviceClassSpec.json
# 11a12,15
# >     "extendedResourceName": {
# >       "description": "ExtendedResourceName is the extended resource name for the devices of this class. The devices of this class can be used to satisfy a pod's extended resource requests. It has the same format as the name of a pod's extended resource. It should be unique among all the device classes in a cluster. If two device classes have the same name, then the class created later is picked to satisfy a pod's extended resource requests. If two classes are created at the same time, then the name of the class lexicographically sorted first is picked.\n\nThis is an alpha field.",
# >       "type": "string"
# >     },
# diff 1.33orig/defs/io.k8s.api.resource.v1beta1.DeviceConstraint.json 1.34orig/defs/io.k8s.api.resource.v1beta1.DeviceConstraint.json
# 3a4,7
# >     "distinctAttribute": {
# >       "description": "DistinctAttribute requires that all devices in question have this attribute and that its type and value are unique across those devices.\n\nThis acts as the inverse of MatchAttribute.\n\nThis constraint is used to avoid allocating multiple requests to the same device by ensuring attribute-level differentiation.\n\nThis is useful for scenarios where resource requests must be fulfilled by separate physical devices. For example, a container requests two network interfaces that must be allocated from two different physical NICs.",
# >       "type": "string"
# >     },
# diff 1.33orig/defs/io.k8s.api.resource.v1beta1.DeviceRequest.json 1.34orig/defs/io.k8s.api.resource.v1beta1.DeviceRequest.json
# 11a12,15
# >     "capacity": {
# >       "$ref": "#/definitions/io.k8s.api.resource.v1beta1.CapacityRequirements",
# >       "description": "Capacity define resource requirements against each capacity.\n\nIf this field is unset and the device supports multiple allocations, the default value will be applied to each capacity according to requestPolicy. For the capacity that has no requestPolicy, default is the full capacity value.\n\nApplies to each device allocation. If Count > 1, the request fails if there aren't enough devices that meet the requirements. If AllocationMode is set to All, the request fails if there are devices that otherwise match the request, and have this capacity, with a value >= the requested amount, but which cannot be allocated to this request."
# >     },
# diff 1.33orig/defs/io.k8s.api.resource.v1beta1.DeviceRequestAllocationResult.json 1.34orig/defs/io.k8s.api.resource.v1beta1.DeviceRequestAllocationResult.json
# 7a8,30
# >     "bindingConditions": {
# >       "description": "BindingConditions contains a copy of the BindingConditions from the corresponding ResourceSlice at the time of allocation.\n\nThis is an alpha field and requires enabling the DRADeviceBindingConditions and DRAResourceClaimDeviceStatus feature gates.",
# >       "items": {
# >         "type": "string"
# >       },
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# >     },
# >     "bindingFailureConditions": {
# >       "description": "BindingFailureConditions contains a copy of the BindingFailureConditions from the corresponding ResourceSlice at the time of allocation.\n\nThis is an alpha field and requires enabling the DRADeviceBindingConditions and DRAResourceClaimDeviceStatus feature gates.",
# >       "items": {
# >         "type": "string"
# >       },
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# >     },
# >     "consumedCapacity": {
# >       "additionalProperties": {
# >         "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
# >       },
# >       "description": "ConsumedCapacity tracks the amount of capacity consumed per device as part of the claim request. The consumed amount may differ from the requested amount: it is rounded up to the nearest valid value based on the device\u2019s requestPolicy if applicable (i.e., may not be less than the requested amount).\n\nThe total consumed capacity for each device must not exceed the DeviceCapacity's Value.\n\nThis field is populated only for devices that allow multiple allocations. All capacity entries are included, even if the consumed amount is zero.",
# >       "type": "object"
# >     },
# 21a45,48
# >       "type": "string"
# >     },
# >     "shareID": {
# >       "description": "ShareID uniquely identifies an individual allocation share of the device, used when the device supports multiple simultaneous allocations. It serves as an additional map key to differentiate concurrent shares of the same device.",
# diff 1.33orig/defs/io.k8s.api.resource.v1beta1.DeviceSubRequest.json 1.34orig/defs/io.k8s.api.resource.v1beta1.DeviceSubRequest.json
# 7a8,11
# >     "capacity": {
# >       "$ref": "#/definitions/io.k8s.api.resource.v1beta1.CapacityRequirements",
# >       "description": "Capacity define resource requirements against each capacity.\n\nIf this field is unset and the device supports multiple allocations, the default value will be applied to each capacity according to requestPolicy. For the capacity that has no requestPolicy, default is the full capacity value.\n\nApplies to each device allocation. If Count > 1, the request fails if there aren't enough devices that meet the requirements. If AllocationMode is set to All, the request fails if there are devices that otherwise match the request, and have this capacity, with a value >= the requested amount, but which cannot be allocated to this request."
# >     },
# diff 1.33orig/defs/io.k8s.api.resource.v1beta1.ResourceClaimStatus.json 1.34orig/defs/io.k8s.api.resource.v1beta1.ResourceClaimStatus.json
# 17c17,18
# <         "pool"
# ---
# >         "pool",
# >         "shareID"
# diff 1.33orig/defs/io.k8s.api.resource.v1beta2.AllocatedDeviceStatus.json 1.34orig/defs/io.k8s.api.resource.v1beta2.AllocatedDeviceStatus.json
# 2c2
# <   "description": "AllocatedDeviceStatus contains the status of an allocated device, if the driver chooses to report it. This may include driver-specific information.",
# ---
# >   "description": "AllocatedDeviceStatus contains the status of an allocated device, if the driver chooses to report it. This may include driver-specific information.\n\nThe combination of Driver, Pool, Device, and ShareID must match the corresponding key in Status.Allocation.Devices.",
# 32a33,36
# >       "type": "string"
# >     },
# >     "shareID": {
# >       "description": "ShareID uniquely identifies an individual allocation share of the device.",
# diff 1.33orig/defs/io.k8s.api.resource.v1beta2.AllocationResult.json 1.34orig/defs/io.k8s.api.resource.v1beta2.AllocationResult.json
# 3a4,7
# >     "allocationTimestamp": {
# >       "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Time",
# >       "description": "AllocationTimestamp stores the time when the resources were allocated. This field is not guaranteed to be set, in which case that time is unknown.\n\nThis is an alpha field and requires enabling the DRADeviceBindingConditions and DRAResourceClaimDeviceStatus feature gate."
# >     },
# diff 1.33orig/defs/io.k8s.api.resource.v1beta2.CELDeviceSelector.json 1.34orig/defs/io.k8s.api.resource.v1beta2.CELDeviceSelector.json
# 5c5
# <       "description": "Expression is a CEL expression which evaluates a single device. It must evaluate to true when the device under consideration satisfies the desired criteria, and false when it does not. Any other result is an error and causes allocation of devices to abort.\n\nThe expression's input is an object named \"device\", which carries the following properties:\n - driver (string): the name of the driver which defines this device.\n - attributes (map[string]object): the device's attributes, grouped by prefix\n   (e.g. device.attributes[\"dra.example.com\"] evaluates to an object with all\n   of the attributes which were prefixed by \"dra.example.com\".\n - capacity (map[string]object): the device's capacities, grouped by prefix.\n\nExample: Consider a device with driver=\"dra.example.com\", which exposes two attributes named \"model\" and \"ext.example.com/family\" and which exposes one capacity named \"modules\". This input to this expression would have the following fields:\n\n    device.driver\n    device.attributes[\"dra.example.com\"].model\n    device.attributes[\"ext.example.com\"].family\n    device.capacity[\"dra.example.com\"].modules\n\nThe device.driver field can be used to check for a specific driver, either as a high-level precondition (i.e. you only want to consider devices from this driver) or as part of a multi-clause expression that is meant to consider devices from different drivers.\n\nThe value type of each attribute is defined by the device definition, and users who write these expressions must consult the documentation for their specific drivers. The value type of each capacity is Quantity.\n\nIf an unknown prefix is used as a lookup in either device.attributes or device.capacity, an empty map will be returned. Any reference to an unknown field will cause an evaluation error and allocation to abort.\n\nA robust expression should check for the existence of attributes before referencing them.\n\nFor ease of use, the cel.bind() function is enabled, and can be used to simplify expressions that access multiple attributes with the same domain. For example:\n\n    cel.bind(dra, device.attributes[\"dra.example.com\"], dra.someBool && dra.anotherBool)\n\nThe length of the expression must be smaller or equal to 10 Ki. The cost of evaluating it is also limited based on the estimated number of logical steps.",
# ---
# >       "description": "Expression is a CEL expression which evaluates a single device. It must evaluate to true when the device under consideration satisfies the desired criteria, and false when it does not. Any other result is an error and causes allocation of devices to abort.\n\nThe expression's input is an object named \"device\", which carries the following properties:\n - driver (string): the name of the driver which defines this device.\n - attributes (map[string]object): the device's attributes, grouped by prefix\n   (e.g. device.attributes[\"dra.example.com\"] evaluates to an object with all\n   of the attributes which were prefixed by \"dra.example.com\".\n - capacity (map[string]object): the device's capacities, grouped by prefix.\n - allowMultipleAllocations (bool): the allowMultipleAllocations property of the device\n   (v1.34+ with the DRAConsumableCapacity feature enabled).\n\nExample: Consider a device with driver=\"dra.example.com\", which exposes two attributes named \"model\" and \"ext.example.com/family\" and which exposes one capacity named \"modules\". This input to this expression would have the following fields:\n\n    device.driver\n    device.attributes[\"dra.example.com\"].model\n    device.attributes[\"ext.example.com\"].family\n    device.capacity[\"dra.example.com\"].modules\n\nThe device.driver field can be used to check for a specific driver, either as a high-level precondition (i.e. you only want to consider devices from this driver) or as part of a multi-clause expression that is meant to consider devices from different drivers.\n\nThe value type of each attribute is defined by the device definition, and users who write these expressions must consult the documentation for their specific drivers. The value type of each capacity is Quantity.\n\nIf an unknown prefix is used as a lookup in either device.attributes or device.capacity, an empty map will be returned. Any reference to an unknown field will cause an evaluation error and allocation to abort.\n\nA robust expression should check for the existence of attributes before referencing them.\n\nFor ease of use, the cel.bind() function is enabled, and can be used to simplify expressions that access multiple attributes with the same domain. For example:\n\n    cel.bind(dra, device.attributes[\"dra.example.com\"], dra.someBool && dra.anotherBool)\n\nThe length of the expression must be smaller or equal to 10 Ki. The cost of evaluating it is also limited based on the estimated number of logical steps.",
# Only in 1.34orig/defs: io.k8s.api.resource.v1beta2.CapacityRequestPolicy.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1beta2.CapacityRequestPolicyRange.json
# Only in 1.34orig/defs: io.k8s.api.resource.v1beta2.CapacityRequirements.json
# diff 1.33orig/defs/io.k8s.api.resource.v1beta2.Device.json 1.34orig/defs/io.k8s.api.resource.v1beta2.Device.json
# 7a8,11
# >     "allowMultipleAllocations": {
# >       "description": "AllowMultipleAllocations marks whether the device is allowed to be allocated to multiple DeviceRequests.\n\nIf AllowMultipleAllocations is set to true, the device can be allocated more than once, and all of its capacity is consumable, regardless of whether the requestPolicy is defined or not.",
# >       "type": "boolean"
# >     },
# 13a18,37
# >     },
# >     "bindingConditions": {
# >       "description": "BindingConditions defines the conditions for proceeding with binding. All of these conditions must be set in the per-device status conditions with a value of True to proceed with binding the pod to the node while scheduling the pod.\n\nThe maximum number of binding conditions is 4.\n\nThe conditions must be a valid condition type string.\n\nThis is an alpha field and requires enabling the DRADeviceBindingConditions and DRAResourceClaimDeviceStatus feature gates.",
# >       "items": {
# >         "type": "string"
# >       },
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# >     },
# >     "bindingFailureConditions": {
# >       "description": "BindingFailureConditions defines the conditions for binding failure. They may be set in the per-device status conditions. If any is set to \"True\", a binding failure occurred.\n\nThe maximum number of binding failure conditions is 4.\n\nThe conditions must be a valid condition type string.\n\nThis is an alpha field and requires enabling the DRADeviceBindingConditions and DRAResourceClaimDeviceStatus feature gates.",
# >       "items": {
# >         "type": "string"
# >       },
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# >     },
# >     "bindsToNode": {
# >       "description": "BindsToNode indicates if the usage of an allocation involving this device has to be limited to exactly the node that was chosen when allocating the claim. If set to true, the scheduler will set the ResourceClaim.Status.Allocation.NodeSelector to match the node where the allocation was made.\n\nThis is an alpha field and requires enabling the DRADeviceBindingConditions and DRAResourceClaimDeviceStatus feature gates.",
# >       "type": "boolean"
# diff 1.33orig/defs/io.k8s.api.resource.v1beta2.DeviceCapacity.json 1.34orig/defs/io.k8s.api.resource.v1beta2.DeviceCapacity.json
# 3a4,7
# >     "requestPolicy": {
# >       "$ref": "#/definitions/io.k8s.api.resource.v1beta2.CapacityRequestPolicy",
# >       "description": "RequestPolicy defines how this DeviceCapacity must be consumed when the device is allowed to be shared by multiple allocations.\n\nThe Device must have allowMultipleAllocations set to true in order to set a requestPolicy.\n\nIf unset, capacity requests are unconstrained: requests can consume any amount of capacity, as long as the total consumed across all allocations does not exceed the device's defined capacity. If request is also unset, default is the full capacity value."
# >     },
# 6c10
# <       "description": "Value defines how much of a certain device capacity is available."
# ---
# >       "description": "Value defines how much of a certain capacity that device has.\n\nThis field reflects the fixed total capacity and does not change. The consumed amount is tracked separately by scheduler and does not affect this value."
# diff 1.33orig/defs/io.k8s.api.resource.v1beta2.DeviceClassSpec.json 1.34orig/defs/io.k8s.api.resource.v1beta2.DeviceClassSpec.json
# 11a12,15
# >     "extendedResourceName": {
# >       "description": "ExtendedResourceName is the extended resource name for the devices of this class. The devices of this class can be used to satisfy a pod's extended resource requests. It has the same format as the name of a pod's extended resource. It should be unique among all the device classes in a cluster. If two device classes have the same name, then the class created later is picked to satisfy a pod's extended resource requests. If two classes are created at the same time, then the name of the class lexicographically sorted first is picked.\n\nThis is an alpha field.",
# >       "type": "string"
# >     },
# diff 1.33orig/defs/io.k8s.api.resource.v1beta2.DeviceConstraint.json 1.34orig/defs/io.k8s.api.resource.v1beta2.DeviceConstraint.json
# 3a4,7
# >     "distinctAttribute": {
# >       "description": "DistinctAttribute requires that all devices in question have this attribute and that its type and value are unique across those devices.\n\nThis acts as the inverse of MatchAttribute.\n\nThis constraint is used to avoid allocating multiple requests to the same device by ensuring attribute-level differentiation.\n\nThis is useful for scenarios where resource requests must be fulfilled by separate physical devices. For example, a container requests two network interfaces that must be allocated from two different physical NICs.",
# >       "type": "string"
# >     },
# diff 1.33orig/defs/io.k8s.api.resource.v1beta2.DeviceRequestAllocationResult.json 1.34orig/defs/io.k8s.api.resource.v1beta2.DeviceRequestAllocationResult.json
# 7a8,30
# >     "bindingConditions": {
# >       "description": "BindingConditions contains a copy of the BindingConditions from the corresponding ResourceSlice at the time of allocation.\n\nThis is an alpha field and requires enabling the DRADeviceBindingConditions and DRAResourceClaimDeviceStatus feature gates.",
# >       "items": {
# >         "type": "string"
# >       },
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# >     },
# >     "bindingFailureConditions": {
# >       "description": "BindingFailureConditions contains a copy of the BindingFailureConditions from the corresponding ResourceSlice at the time of allocation.\n\nThis is an alpha field and requires enabling the DRADeviceBindingConditions and DRAResourceClaimDeviceStatus feature gates.",
# >       "items": {
# >         "type": "string"
# >       },
# >       "type": "array",
# >       "x-kubernetes-list-type": "atomic"
# >     },
# >     "consumedCapacity": {
# >       "additionalProperties": {
# >         "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
# >       },
# >       "description": "ConsumedCapacity tracks the amount of capacity consumed per device as part of the claim request. The consumed amount may differ from the requested amount: it is rounded up to the nearest valid value based on the device\u2019s requestPolicy if applicable (i.e., may not be less than the requested amount).\n\nThe total consumed capacity for each device must not exceed the DeviceCapacity's Value.\n\nThis field is populated only for devices that allow multiple allocations. All capacity entries are included, even if the consumed amount is zero.",
# >       "type": "object"
# >     },
# 21a45,48
# >       "type": "string"
# >     },
# >     "shareID": {
# >       "description": "ShareID uniquely identifies an individual allocation share of the device, used when the device supports multiple simultaneous allocations. It serves as an additional map key to differentiate concurrent shares of the same device.",
# diff 1.33orig/defs/io.k8s.api.resource.v1beta2.DeviceSubRequest.json 1.34orig/defs/io.k8s.api.resource.v1beta2.DeviceSubRequest.json
# 7a8,11
# >     "capacity": {
# >       "$ref": "#/definitions/io.k8s.api.resource.v1beta2.CapacityRequirements",
# >       "description": "Capacity define resource requirements against each capacity.\n\nIf this field is unset and the device supports multiple allocations, the default value will be applied to each capacity according to requestPolicy. For the capacity that has no requestPolicy, default is the full capacity value.\n\nApplies to each device allocation. If Count > 1, the request fails if there aren't enough devices that meet the requirements. If AllocationMode is set to All, the request fails if there are devices that otherwise match the request, and have this capacity, with a value >= the requested amount, but which cannot be allocated to this request."
# >     },
# diff 1.33orig/defs/io.k8s.api.resource.v1beta2.ExactDeviceRequest.json 1.34orig/defs/io.k8s.api.resource.v1beta2.ExactDeviceRequest.json
# 11a12,15
# >     "capacity": {
# >       "$ref": "#/definitions/io.k8s.api.resource.v1beta2.CapacityRequirements",
# >       "description": "Capacity define resource requirements against each capacity.\n\nIf this field is unset and the device supports multiple allocations, the default value will be applied to each capacity according to requestPolicy. For the capacity that has no requestPolicy, default is the full capacity value.\n\nApplies to each device allocation. If Count > 1, the request fails if there aren't enough devices that meet the requirements. If AllocationMode is set to All, the request fails if there are devices that otherwise match the request, and have this capacity, with a value >= the requested amount, but which cannot be allocated to this request."
# >     },
# diff 1.33orig/defs/io.k8s.api.resource.v1beta2.ResourceClaimStatus.json 1.34orig/defs/io.k8s.api.resource.v1beta2.ResourceClaimStatus.json
# 17c17,18
# <         "pool"
# ---
# >         "pool",
# >         "shareID"
# diff 1.33orig/defs/io.k8s.api.storage.v1.CSIDriverSpec.json 1.34orig/defs/io.k8s.api.storage.v1.CSIDriverSpec.json
# 5c5
# <       "description": "attachRequired indicates this CSI volume driver requires an attach operation (because it implements the CSI ControllerPublishVolume() method), and that the Kubernetes attach detach controller should call the attach volume interface which checks the volumeattachment status and waits until the volume is attached before proceeding to mounting. The CSI external-attacher coordinates with CSI volume driver and updates the volumeattachment status when the attach operation is complete. If the CSIDriverRegistry feature gate is enabled and the value is specified to false, the attach operation will be skipped. Otherwise the attach operation will be called.\n\nThis field is immutable.",
# ---
# >       "description": "attachRequired indicates this CSI volume driver requires an attach operation (because it implements the CSI ControllerPublishVolume() method), and that the Kubernetes attach detach controller should call the attach volume interface which checks the volumeattachment status and waits until the volume is attached before proceeding to mounting. The CSI external-attacher coordinates with CSI volume driver and updates the volumeattachment status when the attach operation is complete. If the value is specified to false, the attach operation will be skipped. Otherwise the attach operation will be called.\n\nThis field is immutable.",
# 13c13
# <       "description": "nodeAllocatableUpdatePeriodSeconds specifies the interval between periodic updates of the CSINode allocatable capacity for this driver. When set, both periodic updates and updates triggered by capacity-related failures are enabled. If not set, no updates occur (neither periodic nor upon detecting capacity-related failures), and the allocatable.count remains static. The minimum allowed value for this field is 10 seconds.\n\nThis is an alpha feature and requires the MutableCSINodeAllocatableCount feature gate to be enabled.\n\nThis field is mutable.",
# ---
# >       "description": "nodeAllocatableUpdatePeriodSeconds specifies the interval between periodic updates of the CSINode allocatable capacity for this driver. When set, both periodic updates and updates triggered by capacity-related failures are enabled. If not set, no updates occur (neither periodic nor upon detecting capacity-related failures), and the allocatable.count remains static. The minimum allowed value for this field is 10 seconds.\n\nThis is a beta feature and requires the MutableCSINodeAllocatableCount feature gate to be enabled.\n\nThis field is mutable.",
# Only in 1.34orig/defs: io.k8s.api.storage.v1.VolumeAttributesClass.json
# Only in 1.34orig/defs: io.k8s.api.storage.v1.VolumeAttributesClassList.json

# diff 1.33orig/defs/io.k8s.api.storage.v1.VolumeError.json 1.34orig/defs/io.k8s.api.storage.v1.VolumeError.json
# 5c5
# <       "description": "errorCode is a numeric gRPC code representing the error encountered during Attach or Detach operations.\n\nThis is an optional, alpha field that requires the MutableCSINodeAllocatableCount feature gate being enabled to be set.",
# ---
# >       "description": "errorCode is a numeric gRPC code representing the error encountered during Attach or Detach operations.\n\nThis is an optional, beta field that requires the MutableCSINodeAllocatableCount feature gate being enabled to be set.",

# diff 1.33orig/defs/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions.json 1.34orig/defs/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions.json
# 257,261d256
# <       "version": "v1alpha1"
# <     },
# <     {
# <       "group": "networking.k8s.io",
# <       "kind": "DeleteOptions",
# 302a298,302
# >     },
# >     {
# >       "group": "resource.k8s.io",
# >       "kind": "DeleteOptions",
# >       "version": "v1"
# diff 1.33orig/defs/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent.json 1.34orig/defs/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent.json
# 231,235d230
# <       "version": "v1alpha1"
# <     },
# <     {
# <       "group": "networking.k8s.io",
# <       "kind": "WatchEvent",
# 276a272,276
# >     },
# >     {
# >       "group": "resource.k8s.io",
# >       "kind": "WatchEvent",
# >       "version": "v1"

# Only in 1.34orig/ops: createAdmissionregistrationV1beta1MutatingAdmissionPolicy.json
# Only in 1.34orig/ops: deleteAdmissionregistrationV1beta1CollectionMutatingAdmissionPolicy.json
# Only in 1.34orig/ops: deleteAdmissionregistrationV1beta1MutatingAdmissionPolicy.json
# Only in 1.34orig/ops: listAdmissionregistrationV1beta1MutatingAdmissionPolicy.json
# Only in 1.34orig/ops: patchAdmissionregistrationV1beta1MutatingAdmissionPolicy.json
# Only in 1.34orig/ops: readAdmissionregistrationV1beta1MutatingAdmissionPolicy.json
# Only in 1.34orig/ops: replaceAdmissionregistrationV1beta1MutatingAdmissionPolicy.json
# Only in 1.34orig/ops: watchAdmissionregistrationV1beta1MutatingAdmissionPolicy.json
# Only in 1.34orig/ops: watchAdmissionregistrationV1beta1MutatingAdmissionPolicyList.json

# Only in 1.34orig/ops: createAdmissionregistrationV1beta1MutatingAdmissionPolicyBinding.json
# Only in 1.34orig/ops: deleteAdmissionregistrationV1beta1CollectionMutatingAdmissionPolicyBinding.json
# Only in 1.34orig/ops: deleteAdmissionregistrationV1beta1MutatingAdmissionPolicyBinding.json
# Only in 1.34orig/ops: listAdmissionregistrationV1beta1MutatingAdmissionPolicyBinding.json
# Only in 1.34orig/ops: patchAdmissionregistrationV1beta1MutatingAdmissionPolicyBinding.json
# Only in 1.34orig/ops: readAdmissionregistrationV1beta1MutatingAdmissionPolicyBinding.json
# Only in 1.34orig/ops: replaceAdmissionregistrationV1beta1MutatingAdmissionPolicyBinding.json
# Only in 1.34orig/ops: watchAdmissionregistrationV1beta1MutatingAdmissionPolicyBinding.json
# Only in 1.34orig/ops: watchAdmissionregistrationV1beta1MutatingAdmissionPolicyBindingList.json

# Only in 1.33orig/ops: createAdmissionregistrationV1beta1ValidatingAdmissionPolicy.json
# Only in 1.33orig/ops: deleteAdmissionregistrationV1beta1CollectionValidatingAdmissionPolicy.json
# Only in 1.33orig/ops: deleteAdmissionregistrationV1beta1ValidatingAdmissionPolicy.json
# Only in 1.33orig/ops: listAdmissionregistrationV1beta1ValidatingAdmissionPolicy.json
# Only in 1.33orig/ops: patchAdmissionregistrationV1beta1ValidatingAdmissionPolicy.json
# Only in 1.33orig/ops: patchAdmissionregistrationV1beta1ValidatingAdmissionPolicyStatus.json
# Only in 1.33orig/ops: readAdmissionregistrationV1beta1ValidatingAdmissionPolicy.json
# Only in 1.33orig/ops: readAdmissionregistrationV1beta1ValidatingAdmissionPolicyStatus.json
# Only in 1.33orig/ops: replaceAdmissionregistrationV1beta1ValidatingAdmissionPolicy.json
# Only in 1.33orig/ops: replaceAdmissionregistrationV1beta1ValidatingAdmissionPolicyStatus.json
# Only in 1.33orig/ops: watchAdmissionregistrationV1beta1ValidatingAdmissionPolicy.json
# Only in 1.33orig/ops: watchAdmissionregistrationV1beta1ValidatingAdmissionPolicyList.json

# Only in 1.33orig/ops: createAdmissionregistrationV1beta1ValidatingAdmissionPolicyBinding.json
# Only in 1.33orig/ops: deleteAdmissionregistrationV1beta1CollectionValidatingAdmissionPolicyBinding.json
# Only in 1.33orig/ops: deleteAdmissionregistrationV1beta1ValidatingAdmissionPolicyBinding.json
# Only in 1.33orig/ops: listAdmissionregistrationV1beta1ValidatingAdmissionPolicyBinding.json
# Only in 1.33orig/ops: patchAdmissionregistrationV1beta1ValidatingAdmissionPolicyBinding.json
# Only in 1.33orig/ops: readAdmissionregistrationV1beta1ValidatingAdmissionPolicyBinding.json
# Only in 1.33orig/ops: replaceAdmissionregistrationV1beta1ValidatingAdmissionPolicyBinding.json
# Only in 1.33orig/ops: watchAdmissionregistrationV1beta1ValidatingAdmissionPolicyBinding.json
# Only in 1.33orig/ops: watchAdmissionregistrationV1beta1ValidatingAdmissionPolicyBindingList.json

# Only in 1.34orig/ops: createCertificatesV1alpha1NamespacedPodCertificateRequest.json
# Only in 1.34orig/ops: deleteCertificatesV1alpha1CollectionNamespacedPodCertificateRequest.json
# Only in 1.34orig/ops: deleteCertificatesV1alpha1NamespacedPodCertificateRequest.json
# Only in 1.34orig/ops: listCertificatesV1alpha1NamespacedPodCertificateRequest.json
# Only in 1.34orig/ops: listCertificatesV1alpha1PodCertificateRequestForAllNamespaces.json
# Only in 1.34orig/ops: patchCertificatesV1alpha1NamespacedPodCertificateRequest.json
# Only in 1.34orig/ops: patchCertificatesV1alpha1NamespacedPodCertificateRequestStatus.json
# Only in 1.34orig/ops: readCertificatesV1alpha1NamespacedPodCertificateRequest.json
# Only in 1.34orig/ops: readCertificatesV1alpha1NamespacedPodCertificateRequestStatus.json
# Only in 1.34orig/ops: replaceCertificatesV1alpha1NamespacedPodCertificateRequest.json
# Only in 1.34orig/ops: replaceCertificatesV1alpha1NamespacedPodCertificateRequestStatus.json
# Only in 1.34orig/ops: watchCertificatesV1alpha1NamespacedPodCertificateRequest.json
# Only in 1.34orig/ops: watchCertificatesV1alpha1NamespacedPodCertificateRequestList.json
# Only in 1.34orig/ops: watchCertificatesV1alpha1PodCertificateRequestListForAllNamespaces.json

# Only in 1.34orig/ops: createResourceV1DeviceClass.json
# Only in 1.34orig/ops: deleteResourceV1CollectionDeviceClass.json
# Only in 1.34orig/ops: deleteResourceV1DeviceClass.json
# Only in 1.34orig/ops: listResourceV1DeviceClass.json
# Only in 1.34orig/ops: patchResourceV1DeviceClass.json
# Only in 1.34orig/ops: readResourceV1DeviceClass.json
# Only in 1.34orig/ops: replaceResourceV1DeviceClass.json
# Only in 1.34orig/ops: watchResourceV1DeviceClass.json
# Only in 1.34orig/ops: watchResourceV1DeviceClassList.json

# Only in 1.34orig/ops: createResourceV1NamespacedResourceClaim.json
# Only in 1.34orig/ops: deleteResourceV1CollectionNamespacedResourceClaim.json
# Only in 1.34orig/ops: deleteResourceV1NamespacedResourceClaim.json
# Only in 1.34orig/ops: listResourceV1NamespacedResourceClaim.json
# Only in 1.34orig/ops: listResourceV1ResourceClaimForAllNamespaces.json
# Only in 1.34orig/ops: patchResourceV1NamespacedResourceClaim.json
# Only in 1.34orig/ops: patchResourceV1NamespacedResourceClaimStatus.json
# Only in 1.34orig/ops: readResourceV1NamespacedResourceClaim.json
# Only in 1.34orig/ops: readResourceV1NamespacedResourceClaimStatus.json
# Only in 1.34orig/ops: replaceResourceV1NamespacedResourceClaim.json
# Only in 1.34orig/ops: replaceResourceV1NamespacedResourceClaimStatus.json
# Only in 1.34orig/ops: watchResourceV1NamespacedResourceClaim.json
# Only in 1.34orig/ops: watchResourceV1NamespacedResourceClaimList.json
# Only in 1.34orig/ops: watchResourceV1ResourceClaimListForAllNamespaces.json

# Only in 1.33orig/ops: createResourceV1alpha3NamespacedResourceClaim.json
# Only in 1.33orig/ops: deleteResourceV1alpha3CollectionNamespacedResourceClaim.json
# Only in 1.33orig/ops: deleteResourceV1alpha3NamespacedResourceClaim.json
# Only in 1.33orig/ops: listResourceV1alpha3NamespacedResourceClaim.json
# Only in 1.33orig/ops: listResourceV1alpha3ResourceClaimForAllNamespaces.json
# Only in 1.33orig/ops: patchResourceV1alpha3NamespacedResourceClaim.json
# Only in 1.33orig/ops: patchResourceV1alpha3NamespacedResourceClaimStatus.json
# Only in 1.33orig/ops: readResourceV1alpha3NamespacedResourceClaim.json
# Only in 1.33orig/ops: readResourceV1alpha3NamespacedResourceClaimStatus.json
# Only in 1.33orig/ops: replaceResourceV1alpha3NamespacedResourceClaim.json
# Only in 1.33orig/ops: replaceResourceV1alpha3NamespacedResourceClaimStatus.json
# Only in 1.33orig/ops: watchResourceV1alpha3NamespacedResourceClaim.json
# Only in 1.33orig/ops: watchResourceV1alpha3NamespacedResourceClaimList.json
# Only in 1.33orig/ops: watchResourceV1alpha3ResourceClaimListForAllNamespaces.json

# Only in 1.34orig/ops: createResourceV1NamespacedResourceClaimTemplate.json
# Only in 1.34orig/ops: deleteResourceV1CollectionNamespacedResourceClaimTemplate.json
# Only in 1.34orig/ops: deleteResourceV1NamespacedResourceClaimTemplate.json
# Only in 1.34orig/ops: listResourceV1NamespacedResourceClaimTemplate.json
# Only in 1.34orig/ops: listResourceV1ResourceClaimTemplateForAllNamespaces.json
# Only in 1.34orig/ops: patchResourceV1NamespacedResourceClaimTemplate.json
# Only in 1.34orig/ops: readResourceV1NamespacedResourceClaimTemplate.json
# Only in 1.34orig/ops: replaceResourceV1NamespacedResourceClaimTemplate.json
# Only in 1.34orig/ops: watchResourceV1NamespacedResourceClaimTemplate.json
# Only in 1.34orig/ops: watchResourceV1NamespacedResourceClaimTemplateList.json
# Only in 1.34orig/ops: watchResourceV1ResourceClaimTemplateListForAllNamespaces.json

# Only in 1.33orig/ops: createResourceV1alpha3NamespacedResourceClaimTemplate.json
# Only in 1.33orig/ops: deleteResourceV1alpha3CollectionNamespacedResourceClaimTemplate.json
# Only in 1.33orig/ops: deleteResourceV1alpha3NamespacedResourceClaimTemplate.json
# Only in 1.33orig/ops: listResourceV1alpha3NamespacedResourceClaimTemplate.json
# Only in 1.33orig/ops: listResourceV1alpha3ResourceClaimTemplateForAllNamespaces.json
# Only in 1.33orig/ops: patchResourceV1alpha3NamespacedResourceClaimTemplate.json
# Only in 1.33orig/ops: readResourceV1alpha3NamespacedResourceClaimTemplate.json
# Only in 1.33orig/ops: replaceResourceV1alpha3NamespacedResourceClaimTemplate.json
# Only in 1.33orig/ops: watchResourceV1alpha3NamespacedResourceClaimTemplate.json
# Only in 1.33orig/ops: watchResourceV1alpha3NamespacedResourceClaimTemplateList.json
# Only in 1.33orig/ops: watchResourceV1alpha3ResourceClaimTemplateListForAllNamespaces.json

# Only in 1.34orig/ops: createResourceV1ResourceSlice.json
# Only in 1.34orig/ops: deleteResourceV1CollectionResourceSlice.json
# Only in 1.34orig/ops: deleteResourceV1ResourceSlice.json
# Only in 1.34orig/ops: listResourceV1ResourceSlice.json
# Only in 1.34orig/ops: patchResourceV1ResourceSlice.json
# Only in 1.34orig/ops: readResourceV1ResourceSlice.json
# Only in 1.34orig/ops: replaceResourceV1ResourceSlice.json
# Only in 1.34orig/ops: watchResourceV1ResourceSlice.json
# Only in 1.34orig/ops: watchResourceV1ResourceSliceList.json

# Only in 1.33orig/ops: createResourceV1alpha3ResourceSlice.json
# Only in 1.33orig/ops: deleteResourceV1alpha3CollectionResourceSlice.json
# Only in 1.33orig/ops: deleteResourceV1alpha3ResourceSlice.json
# Only in 1.33orig/ops: listResourceV1alpha3ResourceSlice.json
# Only in 1.33orig/ops: patchResourceV1alpha3ResourceSlice.json
# Only in 1.33orig/ops: readResourceV1alpha3ResourceSlice.json
# Only in 1.33orig/ops: replaceResourceV1alpha3ResourceSlice.json
# Only in 1.33orig/ops: watchResourceV1alpha3ResourceSlice.json
# Only in 1.33orig/ops: watchResourceV1alpha3ResourceSliceList.json

# Only in 1.33orig/ops: createResourceV1alpha3DeviceClass.json
# Only in 1.33orig/ops: deleteResourceV1alpha3CollectionDeviceClass.json
# Only in 1.33orig/ops: deleteResourceV1alpha3DeviceClass.json
# Only in 1.33orig/ops: listResourceV1alpha3DeviceClass.json
# Only in 1.33orig/ops: patchResourceV1alpha3DeviceClass.json
# Only in 1.33orig/ops: readResourceV1alpha3DeviceClass.json
# Only in 1.33orig/ops: replaceResourceV1alpha3DeviceClass.json
# Only in 1.33orig/ops: watchResourceV1alpha3DeviceClass.json
# Only in 1.33orig/ops: watchResourceV1alpha3DeviceClassList.json

# Only in 1.34orig/ops: createStorageV1VolumeAttributesClass.json
# Only in 1.34orig/ops: deleteStorageV1CollectionVolumeAttributesClass.json
# Only in 1.34orig/ops: deleteStorageV1VolumeAttributesClass.json
# Only in 1.34orig/ops: getResourceV1APIResources.json
# Only in 1.34orig/ops: listStorageV1VolumeAttributesClass.json
# Only in 1.34orig/ops: patchStorageV1VolumeAttributesClass.json
# Only in 1.34orig/ops: readStorageV1VolumeAttributesClass.json
# Only in 1.34orig/ops: replaceStorageV1VolumeAttributesClass.json
# Only in 1.34orig/ops: watchStorageV1VolumeAttributesClass.json
# Only in 1.34orig/ops: watchStorageV1VolumeAttributesClassList.json
