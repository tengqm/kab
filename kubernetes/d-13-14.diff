Only in 1.13/defs/: io.k8s.api.admissionregistration.v1alpha1.Initializer.json
Only in 1.13/defs/: io.k8s.api.admissionregistration.v1alpha1.InitializerConfiguration.json
Only in 1.13/defs/: io.k8s.api.admissionregistration.v1alpha1.InitializerConfigurationList.json
Only in 1.13/defs/: io.k8s.api.admissionregistration.v1alpha1.Rule.json
diff 1.13/defs/io.k8s.api.admissionregistration.v1beta1.RuleWithOperations.json 1.14/defs/io.k8s.api.admissionregistration.v1beta1.RuleWithOperations.json
30a31,34
>     },
>     "scope": {
>       "description": "scope specifies the scope of this rule. Valid values are \"Cluster\", \"Namespaced\", and \"*\" \"Cluster\" means that only cluster-scoped resources will match this rule. Namespace API objects are cluster-scoped. \"Namespaced\" means that only namespaced resources will match this rule. \"*\" means that there are no scope restrictions. Subresources match the scope of their parent resource. Default is \"*\".",
>       "type": "string"
diff 1.13/defs/io.k8s.api.admissionregistration.v1beta1.Webhook.json 1.14/defs/io.k8s.api.admissionregistration.v1beta1.Webhook.json
3a4,10
>     "admissionReviewVersions": {
>       "description": "AdmissionReviewVersions is an ordered list of preferred `AdmissionReview` versions the Webhook expects. API server will try to use first version in the list which it supports. If none of the versions specified in this list supported by API server, validation will fail for this object. If a persisted webhook configuration specifies allowed versions and does not include any versions known to the API Server, calls to the webhook will fail and be subject to the failure policy. Default to `['v1beta1']`.",
>       "items": {
>         "type": "string"
>       },
>       "type": "array"
>     },
29a37,41
>     },
>     "timeoutSeconds": {
>       "description": "TimeoutSeconds specifies the timeout for this webhook. After the timeout passes, the webhook call will be ignored or the API call will fail based on the failure policy. The timeout value must be between 1 and 30 seconds. Default to 30 seconds.",
>       "format": "int32",
>       "type": "integer"
diff 1.13/defs/io.k8s.api.apps.v1beta1.RollingUpdateDeployment.json 1.14/defs/io.k8s.api.apps.v1beta1.RollingUpdateDeployment.json
6c6
<       "description": "The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is atmost 130% of desired pods."
---
>       "description": "The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods."
diff 1.13/defs/io.k8s.api.apps.v1beta2.RollingUpdateDeployment.json 1.14/defs/io.k8s.api.apps.v1beta2.RollingUpdateDeployment.json
6c6
<       "description": "The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is atmost 130% of desired pods."
---
>       "description": "The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods."
diff 1.13/defs/io.k8s.api.apps.v1beta2.Scale.json 1.14/defs/io.k8s.api.apps.v1beta2.Scale.json
Only in 1.14/defs/: io.k8s.api.coordination.v1.Lease.json
Only in 1.14/defs/: io.k8s.api.coordination.v1.LeaseList.json
Only in 1.14/defs/: io.k8s.api.coordination.v1.LeaseSpec.json
Only in 1.14/defs/: io.k8s.api.core.v1.CSIVolumeSource.json
diff 1.13/defs/io.k8s.api.core.v1.Lifecycle.json 1.14/defs/io.k8s.api.core.v1.Lifecycle.json
10c10
<       "description": "PreStop is called immediately before a container is terminated. The container is terminated after the handler completes. The reason for termination is passed to the handler. Regardless of the outcome of the handler, the container is eventually terminated. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks"
---
>       "description": "PreStop is called immediately before a container is terminated due to an API request or management event such as liveness probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The reason for termination is passed to the handler. The Pod's termination grace period countdown begins before the PreStop hooked is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period. Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks"
diff 1.13/defs/io.k8s.api.core.v1.PersistentVolumeSpec.json 1.14/defs/io.k8s.api.core.v1.PersistentVolumeSpec.json
44c44
<       "description": "CSI represents storage that handled by an external CSI driver (Beta feature)."
---
>       "description": "CSI represents storage that is handled by an external CSI driver (Beta feature)."
diff 1.13/defs/io.k8s.api.core.v1.PodSpec.json 1.14/defs/io.k8s.api.core.v1.PodSpec.json
102c102
<       "description": "If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to \"True\" More info: https://github.com/kubernetes/community/blob/master/keps/sig-network/0007-pod-ready%2B%2B.md",
---
>       "description": "If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to \"True\" More info: https://git.k8s.io/enhancements/keps/sig-network/0007-pod-ready%2B%2B.md",
113c113
<       "description": "RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the \"legacy\" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://github.com/kubernetes/community/blob/master/keps/sig-node/0014-runtime-class.md This is an alpha feature and may change in the future.",
---
>       "description": "RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the \"legacy\" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://git.k8s.io/enhancements/keps/sig-node/runtime-class.md This is an alpha feature and may change in the future.",
diff 1.13/defs/io.k8s.api.core.v1.QuobyteVolumeSource.json 1.14/defs/io.k8s.api.core.v1.QuobyteVolumeSource.json
15a16,19
>     "tenant": {
>       "description": "Tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned Quobyte volumes, value is set by the plugin",
>       "type": "string"
>     },
diff 1.13/defs/io.k8s.api.core.v1.ServiceSpec.json 1.14/defs/io.k8s.api.core.v1.ServiceSpec.json
44a45,49
>       "x-kubernetes-list-map-keys": [
>         "port",
>         "protocol"
>       ],
>       "x-kubernetes-list-type": "map",
diff 1.13/defs/io.k8s.api.core.v1.Volume.json 1.14/defs/io.k8s.api.core.v1.Volume.json
27a28,31
>     "csi": {
>       "$ref": "#/definitions/io.k8s.api.core.v1.CSIVolumeSource",
>       "description": "CSI (Container Storage Interface) represents storage that is handled by an external CSI driver (Alpha feature)."
>     },
diff 1.13/defs/io.k8s.api.core.v1.VolumeMount.json 1.14/defs/io.k8s.api.core.v1.VolumeMount.json
22a23,26
>     },
>     "subPathExpr": {
>       "description": "Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to \"\" (volume's root). SubPathExpr and SubPath are mutually exclusive. This field is alpha in 1.14.",
>       "type": "string"
Only in 1.14/defs/: io.k8s.api.extensions.v1beta1.AllowedCSIDriver.json
diff 1.13/defs/io.k8s.api.extensions.v1beta1.Ingress.json 1.14/defs/io.k8s.api.extensions.v1beta1.Ingress.json
2c2
<   "description": "Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.",
---
>   "description": "Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. DEPRECATED - This group version of Ingress is deprecated by networking.k8s.io/v1beta1 Ingress. See the release notes for more information.",
diff 1.13/defs/io.k8s.api.extensions.v1beta1.NetworkPolicySpec.json 1.14/defs/io.k8s.api.extensions.v1beta1.NetworkPolicySpec.json
23c23
<       "description": "List of rule types that the NetworkPolicy relates to. Valid options are Ingress, Egress, or Ingress,Egress. If this field is not specified, it will default based on the existence of Ingress or Egress rules; policies that contain an Egress section are assumed to affect Egress, and all policies (whether or not they contain an Ingress section) are assumed to affect Ingress. If you want to write an egress-only policy, you must explicitly specify policyTypes [ \"Egress\" ]. Likewise, if you want to write a policy that specifies that no egress is allowed, you must specify a policyTypes value that include \"Egress\" (since such a policy would not include an Egress section and would otherwise default to just [ \"Ingress\" ]). This field is beta-level in 1.8",
---
>       "description": "List of rule types that the NetworkPolicy relates to. Valid options are \"Ingress\", \"Egress\", or \"Ingress,Egress\". If this field is not specified, it will default based on the existence of Ingress or Egress rules; policies that contain an Egress section are assumed to affect Egress, and all policies (whether or not they contain an Ingress section) are assumed to affect Ingress. If you want to write an egress-only policy, you must explicitly specify policyTypes [ \"Egress\" ]. Likewise, if you want to write a policy that specifies that no egress is allowed, you must specify a policyTypes value that include \"Egress\" (since such a policy would not include an Egress section and would otherwise default to just [ \"Ingress\" ]). This field is beta-level in 1.8",
diff 1.13/defs/io.k8s.api.extensions.v1beta1.PodSecurityPolicySpec.json 1.14/defs/io.k8s.api.extensions.v1beta1.PodSecurityPolicySpec.json
7a8,14
>     "allowedCSIDrivers": {
>       "description": "AllowedCSIDrivers is a whitelist of inline CSI drivers that must be explicitly set to be embedded within a pod spec. An empty value means no CSI drivers can run inline within a pod spec.",
>       "items": {
>         "$ref": "#/definitions/io.k8s.api.extensions.v1beta1.AllowedCSIDriver"
>       },
>       "type": "array"
>     },
diff 1.13/defs/io.k8s.api.extensions.v1beta1.RollingUpdateDeployment.json 1.14/defs/io.k8s.api.extensions.v1beta1.RollingUpdateDeployment.json
6c6
<       "description": "The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. By default, a value of 1 is used. Example: when this is set to 30%, the new RC can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new RC can be scaled up further, ensuring that total number of pods running at any time during the update is atmost 130% of desired pods."
---
>       "description": "The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. By default, a value of 1 is used. Example: when this is set to 30%, the new RC can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new RC can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods."
diff 1.13/defs/io.k8s.api.extensions.v1beta1.Scale.json 1.14/defs/io.k8s.api.extensions.v1beta1.Scale.json
diff 1.13/defs/io.k8s.api.networking.v1.NetworkPolicySpec.json 1.14/defs/io.k8s.api.networking.v1.NetworkPolicySpec.json
23c23
<       "description": "List of rule types that the NetworkPolicy relates to. Valid options are Ingress, Egress, or Ingress,Egress. If this field is not specified, it will default based on the existence of Ingress or Egress rules; policies that contain an Egress section are assumed to affect Egress, and all policies (whether or not they contain an Ingress section) are assumed to affect Ingress. If you want to write an egress-only policy, you must explicitly specify policyTypes [ \"Egress\" ]. Likewise, if you want to write a policy that specifies that no egress is allowed, you must specify a policyTypes value that include \"Egress\" (since such a policy would not include an Egress section and would otherwise default to just [ \"Ingress\" ]). This field is beta-level in 1.8",
---
>       "description": "List of rule types that the NetworkPolicy relates to. Valid options are \"Ingress\", \"Egress\", or \"Ingress,Egress\". If this field is not specified, it will default based on the existence of Ingress or Egress rules; policies that contain an Egress section are assumed to affect Egress, and all policies (whether or not they contain an Ingress section) are assumed to affect Ingress. If you want to write an egress-only policy, you must explicitly specify policyTypes [ \"Egress\" ]. Likewise, if you want to write a policy that specifies that no egress is allowed, you must specify a policyTypes value that include \"Egress\" (since such a policy would not include an Egress section and would otherwise default to just [ \"Ingress\" ]). This field is beta-level in 1.8",
Only in 1.14/defs/: io.k8s.api.networking.v1beta1.HTTPIngressPath.json
Only in 1.14/defs/: io.k8s.api.networking.v1beta1.HTTPIngressRuleValue.json
Only in 1.14/defs/: io.k8s.api.networking.v1beta1.Ingress.json
Only in 1.14/defs/: io.k8s.api.networking.v1beta1.IngressBackend.json
Only in 1.14/defs/: io.k8s.api.networking.v1beta1.IngressList.json
Only in 1.14/defs/: io.k8s.api.networking.v1beta1.IngressRule.json
Only in 1.14/defs/: io.k8s.api.networking.v1beta1.IngressSpec.json
Only in 1.14/defs/: io.k8s.api.networking.v1beta1.IngressStatus.json
Only in 1.14/defs/: io.k8s.api.networking.v1beta1.IngressTLS.json
Only in 1.14/defs/: io.k8s.api.node.v1alpha1.RuntimeClass.json
Only in 1.14/defs/: io.k8s.api.node.v1alpha1.RuntimeClassList.json
Only in 1.14/defs/: io.k8s.api.node.v1alpha1.RuntimeClassSpec.json
Only in 1.14/defs/: io.k8s.api.node.v1beta1.RuntimeClass.json
Only in 1.14/defs/: io.k8s.api.node.v1beta1.RuntimeClassList.json
Only in 1.14/defs/: io.k8s.api.policy.v1beta1.AllowedCSIDriver.json
diff 1.13/defs/io.k8s.api.policy.v1beta1.PodSecurityPolicySpec.json 1.14/defs/io.k8s.api.policy.v1beta1.PodSecurityPolicySpec.json
7a8,14
>     "allowedCSIDrivers": {
>       "description": "AllowedCSIDrivers is a whitelist of inline CSI drivers that must be explicitly set to be embedded within a pod spec. An empty value means no CSI drivers can run inline within a pod spec.",
>       "items": {
>         "$ref": "#/definitions/io.k8s.api.policy.v1beta1.AllowedCSIDriver"
>       },
>       "type": "array"
>     },
diff 1.13/defs/io.k8s.api.rbac.v1.ClusterRole.json 1.14/defs/io.k8s.api.rbac.v1.ClusterRole.json
35d34
<     "rules",
diff 1.13/defs/io.k8s.api.rbac.v1.Role.json 1.14/defs/io.k8s.api.rbac.v1.Role.json
31d30
<     "rules",
diff 1.13/defs/io.k8s.api.rbac.v1alpha1.ClusterRole.json 1.14/defs/io.k8s.api.rbac.v1alpha1.ClusterRole.json
35d34
<     "rules",
diff 1.13/defs/io.k8s.api.rbac.v1alpha1.Role.json 1.14/defs/io.k8s.api.rbac.v1alpha1.Role.json
31d30
<     "rules",
diff 1.13/defs/io.k8s.api.rbac.v1beta1.ClusterRole.json 1.14/defs/io.k8s.api.rbac.v1beta1.ClusterRole.json
35d34
<     "rules",
diff 1.13/defs/io.k8s.api.rbac.v1beta1.Role.json 1.14/defs/io.k8s.api.rbac.v1beta1.Role.json
31d30
<     "rules",
Only in 1.14/defs/: io.k8s.api.scheduling.v1.PriorityClass.json
Only in 1.14/defs/: io.k8s.api.scheduling.v1.PriorityClassList.json
diff 1.13/defs/io.k8s.api.scheduling.v1alpha1.PriorityClass.json 1.14/defs/io.k8s.api.scheduling.v1alpha1.PriorityClass.json
2c2
<   "description": "PriorityClass defines mapping from a priority class name to the priority integer value. The value can be any valid integer.",
---
>   "description": "DEPRECATED - This group version of PriorityClass is deprecated by scheduling.k8s.io/v1/PriorityClass. PriorityClass defines mapping from a priority class name to the priority integer value. The value can be any valid integer.",
diff 1.13/defs/io.k8s.api.scheduling.v1beta1.PriorityClass.json 1.14/defs/io.k8s.api.scheduling.v1beta1.PriorityClass.json
2c2
<   "description": "PriorityClass defines mapping from a priority class name to the priority integer value. The value can be any valid integer.",
---
>   "description": "DEPRECATED - This group version of PriorityClass is deprecated by scheduling.k8s.io/v1/PriorityClass. PriorityClass defines mapping from a priority class name to the priority integer value. The value can be any valid integer.",
diff 1.13/defs/io.k8s.api.storage.v1.VolumeError.json 1.14/defs/io.k8s.api.storage.v1.VolumeError.json
Only in 1.14/defs/: io.k8s.api.storage.v1beta1.CSIDriver.json
Only in 1.14/defs/: io.k8s.api.storage.v1beta1.CSIDriverList.json
Only in 1.14/defs/: io.k8s.api.storage.v1beta1.CSIDriverSpec.json
Only in 1.14/defs/: io.k8s.api.storage.v1beta1.CSINode.json
Only in 1.14/defs/: io.k8s.api.storage.v1beta1.CSINodeDriver.json
Only in 1.14/defs/: io.k8s.api.storage.v1beta1.CSINodeList.json
Only in 1.14/defs/: io.k8s.api.storage.v1beta1.CSINodeSpec.json
diff 1.13/defs/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceConversion.json 1.14/defs/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceConversion.json
3a4,10
>     "conversionReviewVersions": {
>       "description": "ConversionReviewVersions is an ordered list of preferred `ConversionReview` versions the Webhook expects. API server will try to use first version in the list which it supports. If none of the versions specified in this list supported by API server, conversion will fail for this object. If a persisted Webhook configuration specifies allowed versions and does not include any versions known to the API Server, calls to the webhook will fail. Default to `['v1beta1']`.",
>       "items": {
>         "type": "string"
>       },
>       "type": "array"
>     },
diff 1.13/defs/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceSubresourceStatus.json 1.14/defs/io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceSubresourceStatus.json
2c2,3
<   "description": "CustomResourceSubresourceStatus defines how to serve the status subresource for CustomResources. Status is represented by the `.status` JSON path inside of a CustomResource. When set, * exposes a /status subresource for the custom resource * PUT requests to the /status subresource take a custom resource object, and ignore changes to anything except the status stanza * PUT/POST/PATCH requests to the custom resource ignore changes to the status stanza"
---
>   "description": "CustomResourceSubresourceStatus defines how to serve the status subresource for CustomResources. Status is represented by the `.status` JSON path inside of a CustomResource. When set, * exposes a /status subresource for the custom resource * PUT requests to the /status subresource take a custom resource object, and ignore changes to anything except the status stanza * PUT/POST/PATCH requests to the custom resource ignore changes to the status stanza",
>   "type": "object"
diff 1.13/defs/io.k8s.apimachinery.pkg.apis.meta.v1.APIResource.json 1.14/defs/io.k8s.apimachinery.pkg.apis.meta.v1.APIResource.json
37a38,41
>     "storageVersionHash": {
>       "description": "The hash value of the storage version, the version this resource is converted to when written to the data store. Value must be treated as opaque by clients. Only equality comparison on the value is valid. This is an alpha feature and may change or be removed in the future. The field is populated by the apiserver only if the StorageVersionHash feature gate is enabled. This field will remain optional even if it graduates.",
>       "type": "string"
>     },
diff 1.13/defs/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions.json 1.14/defs/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions.json
52,56d51
<       "version": "v1alpha1"
<     },
<     {
<       "group": "admissionregistration.k8s.io",
<       "kind": "DeleteOptions",
151a147,151
>       "version": "v1"
>     },
>     {
>       "group": "coordination.k8s.io",
>       "kind": "DeleteOptions",
174a175,189
>       "group": "networking.k8s.io",
>       "kind": "DeleteOptions",
>       "version": "v1beta1"
>     },
>     {
>       "group": "node.k8s.io",
>       "kind": "DeleteOptions",
>       "version": "v1alpha1"
>     },
>     {
>       "group": "node.k8s.io",
>       "kind": "DeleteOptions",
>       "version": "v1beta1"
>     },
>     {
196a212,216
>       "version": "v1"
>     },
>     {
>       "group": "scheduling.k8s.io",
>       "kind": "DeleteOptions",
Only in 1.14/defs/: io.k8s.apimachinery.pkg.apis.meta.v1.Fields.json
Only in 1.14/defs/: io.k8s.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry.json
diff 1.13/defs/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta.json 1.14/defs/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta.json
47c47
<       "description": "An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.\n\nWhen an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user."
---
>       "description": "An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.\n\nWhen an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.\n\nDEPRECATED - initializers are an alpha field and will be removed in v1.15."
55a56,62
>     "managedFields": {
>       "description": "ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like \"ci-cd\". The set of fields is always in the version that the workflow used when modifying the object.\n\nThis field is alpha and can be changed or removed without notice.",
>       "items": {
>         "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry"
>       },
>       "type": "array"
>     },
diff 1.13/defs/io.k8s.apimachinery.pkg.apis.meta.v1.Patch.json 1.14/defs/io.k8s.apimachinery.pkg.apis.meta.v1.Patch.json
2c2,3
<   "description": "Patch is provided to give a concrete name and type to the Kubernetes PATCH request body."
---
>   "description": "Patch is provided to give a concrete name and type to the Kubernetes PATCH request body.",
>   "type": "object"
diff 1.13/defs/io.k8s.apimachinery.pkg.apis.meta.v1.Preconditions.json 1.14/defs/io.k8s.apimachinery.pkg.apis.meta.v1.Preconditions.json
3a4,7
>     "resourceVersion": {
>       "description": "Specifies the target ResourceVersion",
>       "type": "string"
>     },
diff 1.13/defs/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent.json 1.14/defs/io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent.json
31,35d30
<       "version": "v1alpha1"
<     },
<     {
<       "group": "admissionregistration.k8s.io",
<       "kind": "WatchEvent",
130a126,130
>       "version": "v1"
>     },
>     {
>       "group": "coordination.k8s.io",
>       "kind": "WatchEvent",
153a154,168
>       "group": "networking.k8s.io",
>       "kind": "WatchEvent",
>       "version": "v1beta1"
>     },
>     {
>       "group": "node.k8s.io",
>       "kind": "WatchEvent",
>       "version": "v1alpha1"
>     },
>     {
>       "group": "node.k8s.io",
>       "kind": "WatchEvent",
>       "version": "v1beta1"
>     },
>     {
175a191,195
>       "version": "v1"
>     },
>     {
>       "group": "scheduling.k8s.io",
>       "kind": "WatchEvent",
diff 1.13/defs/io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.APIServiceCondition.json 1.14/defs/io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.APIServiceCondition.json
1a2
>   "description": "APIServiceCondition describes the state of an APIService at a particular point",
diff 1.13/defs/io.k8s.kube-aggregator.pkg.apis.apiregistration.v1beta1.APIServiceCondition.json 1.14/defs/io.k8s.kube-aggregator.pkg.apis.apiregistration.v1beta1.APIServiceCondition.json
1a2
>   "description": "APIServiceCondition describes the state of an APIService at a particular point",
